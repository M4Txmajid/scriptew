-- ================================================================
-- STEALTH & ANTI-DETECTION
-- ================================================================
local stealthMode = true
local hiddenGuis = {}

local function debugPrint(msg)
    if not stealthMode then
        print("[MuslimDev] " .. tostring(msg))
    end
end

debugPrint("Script starting with stealth mode...")

-- ================================================================
-- HOOKMETAMETHOD - ANTI-KICK/BAN/DETECTION
-- ================================================================
local function SetupAntiKick()
    pcall(function()
        local mt = getrawmetatable(game)
        local oldNamecall = mt.__namecall
        local oldIndex = mt.__index
        
        setreadonly(mt, false)
        
        -- Anti-Kick/Ban Namecall Hook
        mt.__namecall = newcclosure(function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            -- Block kick attempts
            if method == "Kick" or method == "kick" then
                debugPrint("ðŸ›¡ï¸ BLOCKED KICK ATTEMPT")
                return nil
            end
            
            -- Block ban attempts
            if method == "Ban" or method == "ban" then
                debugPrint("ðŸ›¡ï¸ BLOCKED BAN ATTEMPT")
                return nil
            end
            
            -- Block TeleportToPlaceInstance (server hop kicks)
            if method == "TeleportToPlaceInstance" then
                debugPrint("ðŸ›¡ï¸ BLOCKED TELEPORT KICK")
                return nil
            end
            
            -- Block common anti-cheat remotes
            if method == "FireServer" or method == "InvokeServer" then
                local remoteName = tostring(self)
                
                -- Block common detection remotes
                if remoteName:lower():find("anti") or 
                   remoteName:lower():find("cheat") or 
                   remoteName:lower():find("detect") or
                   remoteName:lower():find("ban") or
                   remoteName:lower():find("kick") or
                   remoteName:lower():find("flag") or
                   remoteName:lower():find("report") then
                    debugPrint("ðŸ›¡ï¸ BLOCKED ANTI-CHEAT REMOTE: " .. remoteName)
                    return nil
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        -- Hide script detection
        mt.__index = newcclosure(function(self, key)
            -- Hide our GUIs from detection
            if hiddenGuis[self] and key == "Parent" then
                return nil
            end
            
            return oldIndex(self, key)
        end)
        
        setreadonly(mt, true)
        debugPrint("âœ… Hookmetamethod bypass active")
    end)
end

SetupAntiKick()

-- ================================================================
-- DISCORD AUTO-JOIN
-- ================================================================
local DISCORD_LINK = "https://discord.gg/Yq4u8sz4yD" -- CHANGE THIS

local function OpenDiscord()
    pcall(function()
        if syn and syn.request then
            syn.request({
                Url = "http://127.0.0.1:6463/rpc?v=1",
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json",
                    ["Origin"] = "https://discord.gg/sBymGpmC"
                },
                Body = game:GetService("HttpService"):JSONEncode({
                    cmd = "INVITE_BROWSER",
                    args = {code = DISCORD_LINK:match("discord.gg/(.+)")}
                })
            })
            debugPrint("Discord opened via RPC")
        end
    end)
    
    pcall(function()
        if setclipboard then
            setclipboard(DISCORD_LINK)
            game.StarterGui:SetCore("SendNotification", {
                Title = "Discord Link Copied!",
                Text = "Paste in browser to join",
                Duration = 10
            })
            debugPrint("Discord link copied to clipboard")
        end
    end)
end

task.delay(3, function()
    OpenDiscord()
end)

local success, errorMsg = pcall(function()

local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Teams = game:GetService("Teams")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")

debugPrint("Services loaded")

local player = Players.LocalPlayer
local playerGui

-- STEALTH: Try to parent to CoreGui (hidden from game scripts)
pcall(function()
    if gethui then
        playerGui = gethui()
        debugPrint("âœ… Using gethui() - Maximum stealth")
    elseif syn and syn.protect_gui then
        playerGui = CoreGui
        debugPrint("âœ… Using CoreGui with protection")
    else
        playerGui = player:WaitForChild("PlayerGui", 10)
        debugPrint("âš ï¸ Using PlayerGui - Less stealth")
    end
end)

if not playerGui then
    playerGui = player:WaitForChild("PlayerGui", 10)
end

local camera = workspace.CurrentCamera
local mouse = player:GetMouse()

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local isTablet = UserInputService.TouchEnabled and (camera.ViewportSize.X > 1000)

debugPrint("Platform: " .. (isMobile and "Mobile" or (isTablet and "Tablet" or "PC")))

-- ================================================================
-- ANTI-DETECTION FEATURES
-- ================================================================

-- Hide from GetDescendants
local function ProtectInstance(instance)
    pcall(function()
        if syn and syn.protect_gui then
            syn.protect_gui(instance)
            debugPrint("Protected: " .. instance.Name)
        end
        hiddenGuis[instance] = true
    end)
end

-- Block screenshot detection
pcall(function()
    local oldFireServer = Instance.new("RemoteEvent").FireServer
    
    game:GetService("ReplicatedStorage").DescendantAdded:Connect(function(descendant)
        if descendant:IsA("RemoteEvent") or descendant:IsA("RemoteFunction") then
            local name = descendant.Name:lower()
            if name:find("screenshot") or name:find("capture") or name:find("image") then
                descendant:Destroy()
                debugPrint("ðŸ›¡ï¸ Blocked screenshot remote: " .. descendant.Name)
            end
        end
    end)
end)

-- Anti-AFK
task.spawn(function()
    while task.wait(60) do
        pcall(function()
            local VirtualUser = game:GetService("VirtualUser")
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end)

debugPrint("âœ… Anti-detection active")

-- YELLOW THEME COLORS
local Theme = {
    Primary = Color3.fromRGB(255, 215, 0),
    Secondary = Color3.fromRGB(255, 235, 100),
    Dark = Color3.fromRGB(40, 35, 0),
    DarkAlt = Color3.fromRGB(60, 50, 0),
    Text = Color3.fromRGB(180, 180, 180),
    TextDark = Color3.fromRGB(40, 35, 0),
    On = Color3.fromRGB(100, 255, 100),
    Off = Color3.fromRGB(255, 100, 100),
    Accent = Color3.fromRGB(255, 180, 0)
}

local Settings = {
    Aimbot = {
        Enabled = true,
        ShootToLock = true,
        Checks = {
            Team = true,
            Wall = false
        },
        HitPart = "Head",
        AutoPrediction = true,
        VelocityPrediction = {
            Enabled = true,
            Value = 0.13
        },
        FOV = {
            Radius = isMobile and 200 or 150,
            Visible = true
        },
        HitboxExpander = {
            Enabled = false,
            Size = 5
        }
    },
    ESP = {
        Enabled = true,
        ShowHealth = true,
        ShowDistance = true,
        ShowName = true,
        ShowBoxes = true,
        BoxColor = Theme.Primary,
        MaxDistance = 1000
    },
    Tracers = {
        Enabled = false,
        Color = Theme.Primary,
        Thickness = 2,
        FromCenter = true,
        MaxDistance = 500
    },
    Stealth = {
        HideConsole = true,
        AntiKick = true,
        AntiDetection = true
    }
}

debugPrint("Settings initialized")

-- IMPROVED SHOOTING STATE
local isActuallyShooting = false
local mouseDown = false
local lastShotTime = 0

local function SetupShootDetection()
    mouse.Button1Down:Connect(function()
        mouseDown = true
        task.wait(0.05)
        if mouseDown then
            isActuallyShooting = true
            debugPrint("SHOOTING ACTIVE")
        end
    end)
    
    mouse.Button1Up:Connect(function()
        mouseDown = false
        isActuallyShooting = false
        debugPrint("SHOOTING STOPPED")
    end)
    
    local activeTouches = {}
    
    UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
        local screenWidth = camera.ViewportSize.X
        if touch.Position.X > screenWidth * 0.5 then
            activeTouches[touch] = true
            task.wait(0.05)
            if activeTouches[touch] then
                isActuallyShooting = true
                debugPrint("MOBILE SHOOTING ACTIVE")
            end
        end
    end)
    
    UserInputService.TouchEnded:Connect(function(touch, gameProcessed)
        if activeTouches[touch] then
            activeTouches[touch] = nil
            isActuallyShooting = false
            debugPrint("MOBILE SHOOTING STOPPED")
        end
    end)
end

SetupShootDetection()
debugPrint("Shoot detection initialized")

-- AUTO PREDICTION
local function GetPlayerPing()
    local ping = 0
    pcall(function()
        ping = player:GetNetworkPing() * 1000
    end)
    return ping
end

local function GetPredictionValue(ping)
    if ping >= 140 then return 0.145
    elseif ping >= 110 then return 0.141
    elseif ping >= 90 then return 0.129
    elseif ping >= 70 then return 0.135
    elseif ping >= 60 then return 0.127
    elseif ping >= 40 then return 0.145
    elseif ping >= 20 then return 0.130
    else return 0.13 end
end

task.spawn(function()
    while task.wait(2) do
        if Settings.Aimbot.AutoPrediction then
            local ping = GetPlayerPing()
            Settings.Aimbot.VelocityPrediction.Value = GetPredictionValue(ping)
        end
    end
end)

debugPrint("Auto-prediction initialized")

local function GetScreenCenter()
    local viewportSize = camera.ViewportSize
    return Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
end

-- FOV CIRCLE
local FOVGui = Instance.new("ScreenGui")
FOVGui.Name = "FOVCircle_" .. math.random(1000, 9999) -- Random name for stealth
FOVGui.ResetOnSpawn = false
FOVGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
FOVGui.IgnoreGuiInset = true
FOVGui.Parent = playerGui
ProtectInstance(FOVGui)

local FOVCircle = Instance.new("Frame")
FOVCircle.Name = "Circle"
FOVCircle.AnchorPoint = Vector2.new(0.5, 0.5)
FOVCircle.BackgroundColor3 = Theme.Primary
FOVCircle.BackgroundTransparency = 0.92
FOVCircle.BorderSizePixel = 0
FOVCircle.Parent = FOVGui

local FOVCorner = Instance.new("UICorner")
FOVCorner.CornerRadius = UDim.new(1, 0)
FOVCorner.Parent = FOVCircle

local FOVStroke = Instance.new("UIStroke")
FOVStroke.Color = Theme.Primary
FOVStroke.Thickness = 2
FOVStroke.Transparency = 0.2
FOVStroke.Parent = FOVCircle

local LockIndicator = Instance.new("TextLabel")
LockIndicator.Name = "LockIndicator"
LockIndicator.Size = UDim2.fromOffset(150, 30)
LockIndicator.AnchorPoint = Vector2.new(0.5, 0)
LockIndicator.BackgroundColor3 = Theme.Dark
LockIndicator.BackgroundTransparency = 0.3
LockIndicator.Font = Enum.Font.GothamBlack
LockIndicator.Text = ""
LockIndicator.TextColor3 = Theme.Primary
LockIndicator.TextSize = 14
LockIndicator.Visible = false
LockIndicator.Parent = FOVGui

local LockCorner = Instance.new("UICorner")
LockCorner.CornerRadius = UDim.new(0, 6)
LockCorner.Parent = LockIndicator

local Target = nil

RunService.RenderStepped:Connect(function()
    local center = GetScreenCenter()
    
    if Settings.Aimbot.FOV.Visible and Settings.Aimbot.Enabled then
        local radius = Settings.Aimbot.FOV.Radius
        FOVCircle.Position = UDim2.fromOffset(center.X, center.Y)
        FOVCircle.Size = UDim2.fromOffset(radius * 2, radius * 2)
        FOVCircle.Visible = true
        
        if isActuallyShooting and Target then
            FOVStroke.Color = Color3.fromRGB(50, 255, 50)
            FOVCircle.BackgroundColor3 = Color3.fromRGB(50, 255, 50)
        else
            FOVStroke.Color = Theme.Primary
            FOVCircle.BackgroundColor3 = Theme.Primary
        end
    else
        FOVCircle.Visible = false
    end
    
    if isActuallyShooting and Target and Settings.Aimbot.Enabled then
        LockIndicator.Position = UDim2.fromOffset(center.X, center.Y - Settings.Aimbot.FOV.Radius - 40)
        LockIndicator.Text = "LOCKED: " .. Target.Name
        LockIndicator.Visible = true
    else
        LockIndicator.Visible = false
    end
end)

debugPrint("FOV Circle created")

-- ESP SYSTEM
local ESPGui = Instance.new("ScreenGui")
ESPGui.Name = "ESP_" .. math.random(1000, 9999)
ESPGui.ResetOnSpawn = false
ESPGui.IgnoreGuiInset = true
ESPGui.Parent = playerGui
ProtectInstance(ESPGui)

local ESPObjects = {}

local function CreateESPForPlayer(targetPlayer)
    if targetPlayer == player then return end
    if ESPObjects[targetPlayer] then return end
    
    debugPrint("Creating ESP for: " .. targetPlayer.Name)
    
    local esp = {}
    
    esp.Billboard = Instance.new("BillboardGui")
    esp.Billboard.Name = targetPlayer.Name .. "_ESP"
    esp.Billboard.AlwaysOnTop = true
    esp.Billboard.Size = UDim2.new(0, 150, 0, 50)
    esp.Billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    esp.Billboard.Parent = ESPGui
    
    esp.NameLabel = Instance.new("TextLabel")
    esp.NameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    esp.NameLabel.BackgroundTransparency = 1
    esp.NameLabel.Font = Enum.Font.GothamBold
    esp.NameLabel.TextColor3 = Theme.Primary
    esp.NameLabel.TextSize = 14
    esp.NameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    esp.NameLabel.TextStrokeTransparency = 0.2
    esp.NameLabel.Parent = esp.Billboard
    
    esp.DistLabel = Instance.new("TextLabel")
    esp.DistLabel.Size = UDim2.new(1, 0, 0.5, 0)
    esp.DistLabel.Position = UDim2.new(0, 0, 0.5, 0)
    esp.DistLabel.BackgroundTransparency = 1
    esp.DistLabel.Font = Enum.Font.Gotham
    esp.DistLabel.TextColor3 = Color3.fromRGB(255, 255, 200)
    esp.DistLabel.TextSize = 12
    esp.DistLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    esp.DistLabel.TextStrokeTransparency = 0.2
    esp.DistLabel.Parent = esp.Billboard
    
    esp.HealthBillboard = Instance.new("BillboardGui")
    esp.HealthBillboard.Name = targetPlayer.Name .. "_Health"
    esp.HealthBillboard.AlwaysOnTop = true
    esp.HealthBillboard.Size = UDim2.new(0, 70, 0, 8)
    esp.HealthBillboard.StudsOffset = Vector3.new(0, 3.5, 0)
    esp.HealthBillboard.Parent = ESPGui
    
    esp.HealthBG = Instance.new("Frame")
    esp.HealthBG.Size = UDim2.new(1, 0, 1, 0)
    esp.HealthBG.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    esp.HealthBG.BorderSizePixel = 0
    esp.HealthBG.Parent = esp.HealthBillboard
    
    local hbgCorner = Instance.new("UICorner")
    hbgCorner.CornerRadius = UDim.new(0, 3)
    hbgCorner.Parent = esp.HealthBG
    
    esp.HealthBar = Instance.new("Frame")
    esp.HealthBar.Size = UDim2.new(1, 0, 1, 0)
    esp.HealthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    esp.HealthBar.BorderSizePixel = 0
    esp.HealthBar.Parent = esp.HealthBG
    
    local hbCorner = Instance.new("UICorner")
    hbCorner.CornerRadius = UDim.new(0, 3)
    hbCorner.Parent = esp.HealthBar
    
    esp.Box = Instance.new("Frame")
    esp.Box.Name = targetPlayer.Name .. "_Box"
    esp.Box.BackgroundTransparency = 1
    esp.Box.BorderSizePixel = 0
    esp.Box.Parent = ESPGui
    
    esp.BoxStroke = Instance.new("UIStroke")
    esp.BoxStroke.Color = Theme.Primary
    esp.BoxStroke.Thickness = 2
    esp.BoxStroke.Transparency = 0.3
    esp.BoxStroke.Parent = esp.Box
    
    local boxCorner = Instance.new("UICorner")
    boxCorner.CornerRadius = UDim.new(0, 4)
    boxCorner.Parent = esp.Box
    
    esp.Tracer = Instance.new("Frame")
    esp.Tracer.Name = targetPlayer.Name .. "_Tracer"
    esp.Tracer.BackgroundColor3 = Theme.Primary
    esp.Tracer.BorderSizePixel = 0
    esp.Tracer.AnchorPoint = Vector2.new(0, 0.5)
    esp.Tracer.ZIndex = 1
    esp.Tracer.Parent = ESPGui
    
    local tracerGradient = Instance.new("UIGradient")
    tracerGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.3),
        NumberSequenceKeypoint.new(1, 0.8)
    })
    tracerGradient.Parent = esp.Tracer
    
    ESPObjects[targetPlayer] = esp
end

local function UpdateESP()
    for targetPlayer, esp in pairs(ESPObjects) do
        pcall(function()
            if not targetPlayer or not targetPlayer.Parent then
                for _, obj in pairs(esp) do
                    if typeof(obj) == "Instance" and obj.Parent then 
                        obj:Destroy() 
                    end
                end
                ESPObjects[targetPlayer] = nil
                return
            end
            
            local char = targetPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChild("Humanoid")
            
            if not (char and hrp and hum and hum.Health > 0) then
                esp.Billboard.Enabled = false
                esp.HealthBillboard.Enabled = false
                esp.Box.Visible = false
                esp.Tracer.Visible = false
                return
            end
            
            local dist = (hrp.Position - camera.CFrame.Position).Magnitude
            local shouldShow = Settings.ESP.Enabled and dist <= Settings.ESP.MaxDistance
            
            if not shouldShow then
                esp.Billboard.Enabled = false
                esp.HealthBillboard.Enabled = false
                esp.Box.Visible = false
                esp.Tracer.Visible = false
                return
            end
            
            local screenPos, onScreen = camera:WorldToViewportPoint(hrp.Position)
            
            esp.Billboard.Adornee = hrp
            esp.Billboard.Enabled = true
            
            if Settings.ESP.ShowName then
                esp.NameLabel.Text = targetPlayer.Name
                esp.NameLabel.Visible = true
            else
                esp.NameLabel.Visible = false
            end
            
            if Settings.ESP.ShowDistance then
                esp.DistLabel.Text = string.format("[%dm]", math.floor(dist))
                esp.DistLabel.Visible = true
            else
                esp.DistLabel.Visible = false
            end
            
            if Settings.ESP.ShowHealth then
                esp.HealthBillboard.Adornee = hrp
                esp.HealthBillboard.Enabled = true
                local ratio = hum.Health / hum.MaxHealth
                esp.HealthBar.Size = UDim2.new(ratio, 0, 1, 0)
                
                if ratio > 0.6 then
                    esp.HealthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                elseif ratio > 0.3 then
                    esp.HealthBar.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                else
                    esp.HealthBar.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                end
            else
                esp.HealthBillboard.Enabled = false
            end
            
            if Settings.ESP.ShowBoxes and onScreen then
                local headPos = head and head.Position or hrp.Position + Vector3.new(0, 2, 0)
                local footPos = hrp.Position - Vector3.new(0, 3, 0)
                
                local headScreen = camera:WorldToViewportPoint(headPos + Vector3.new(0, 0.5, 0))
                local footScreen = camera:WorldToViewportPoint(footPos)
                
                local height = math.abs(headScreen.Y - footScreen.Y)
                local width = height * 0.45
                
                esp.Box.Size = UDim2.fromOffset(width, height)
                esp.Box.Position = UDim2.fromOffset(screenPos.X - width/2, headScreen.Y)
                esp.Box.Visible = true
                esp.BoxStroke.Color = Settings.ESP.BoxColor
            else
                esp.Box.Visible = false
            end
            
            if Settings.Tracers.Enabled and onScreen and dist <= Settings.Tracers.MaxDistance then
                local screenSize = camera.ViewportSize
                local startX, startY
                
                if Settings.Tracers.FromCenter then
                    startX = screenSize.X / 2
                    startY = screenSize.Y / 2
                else
                    startX = screenSize.X / 2
                    startY = screenSize.Y
                end
                
                local endX, endY = screenPos.X, screenPos.Y
                
                local dx = endX - startX
                local dy = endY - startY
                local length = math.sqrt(dx*dx + dy*dy)
                local angle = math.deg(math.atan2(dy, dx))
                
                esp.Tracer.Size = UDim2.fromOffset(length, Settings.Tracers.Thickness)
                esp.Tracer.Position = UDim2.fromOffset(startX, startY)
                esp.Tracer.Rotation = angle
                esp.Tracer.BackgroundColor3 = Settings.Tracers.Color
                esp.Tracer.Visible = true
            else
                esp.Tracer.Visible = false
            end
        end)
    end
end

for _, plr in pairs(Players:GetPlayers()) do
    if plr ~= player then
        CreateESPForPlayer(plr)
    end
end

Players.PlayerAdded:Connect(function(plr)
    task.wait(1)
    CreateESPForPlayer(plr)
end)

Players.PlayerRemoving:Connect(function(plr)
    if ESPObjects[plr] then
        for _, obj in pairs(ESPObjects[plr]) do
            if typeof(obj) == "Instance" and obj.Parent then 
                obj:Destroy() 
            end
        end
        ESPObjects[plr] = nil
    end
end)

RunService.RenderStepped:Connect(UpdateESP)

debugPrint("ESP and Tracers initialized")

-- HITBOX EXPANDER
local originalSizes = {}

local function ExpandHitboxes()
    for _, targetPlayer in pairs(Players:GetPlayers()) do
        if targetPlayer ~= player and targetPlayer.Character then
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                if Settings.Aimbot.HitboxExpander.Enabled then
                    if not originalSizes[targetPlayer] then
                        originalSizes[targetPlayer] = hrp.Size
                    end
                    hrp.Size = Vector3.new(
                        Settings.Aimbot.HitboxExpander.Size,
                        Settings.Aimbot.HitboxExpander.Size,
                        Settings.Aimbot.HitboxExpander.Size
                    )
                    hrp.Transparency = 0.7
                    hrp.CanCollide = false
                else
                    if originalSizes[targetPlayer] then
                        hrp.Size = originalSizes[targetPlayer]
                        hrp.Transparency = 1
                    end
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(ExpandHitboxes)

debugPrint("Hitbox expander initialized")

-- AIMBOT SYSTEM
local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge
    
    local teamCount = #Teams:GetTeams()
    local isFFA = teamCount == 0 or teamCount == 1

    for _, targetPlayer in pairs(Players:GetPlayers()) do
        if targetPlayer ~= player and targetPlayer.Character then
            local char = targetPlayer.Character
            local humanoid = char:FindFirstChild("Humanoid")
            local head = char:FindFirstChild("Head")
            local rootPart = char:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoid.Health > 0 and head and rootPart then
                local skipPlayer = false
                
                if Settings.Aimbot.Checks.Team and not isFFA then
                    if player.Team and targetPlayer.Team and player.Team == targetPlayer.Team then
                        skipPlayer = true
                    end
                end

                if not skipPlayer and Settings.Aimbot.Checks.Wall then
                    local origin = camera.CFrame.Position
                    local direction = (head.Position - origin).Unit * 500
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {player.Character, camera}
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    
                    local result = workspace:Raycast(origin, direction, raycastParams)
                    if result and result.Instance and not result.Instance:IsDescendantOf(char) then
                        skipPlayer = true
                    end
                end

                if not skipPlayer then
                    local screenPos, onScreen = camera:WorldToScreenPoint(head.Position)
                    
                    if onScreen then
                        local center = GetScreenCenter()
                        local dist = (Vector2.new(center.X, center.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                        
                        if dist <= Settings.Aimbot.FOV.Radius and dist < shortestDistance then
                            closestPlayer = targetPlayer
                            shortestDistance = dist
                        end
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function AimAt(target)
    if not target or not target.Character then return end
    
    local head = target.Character:FindFirstChild("Head")
    if not head then return end
    
    local targetPos = head.Position

    if Settings.Aimbot.VelocityPrediction.Enabled then
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local vel = hrp.AssemblyLinearVelocity or hrp.Velocity
            targetPos = targetPos + vel * Settings.Aimbot.VelocityPrediction.Value
        end
    end

    camera.CFrame = CFrame.new(camera.CFrame.Position, targetPos)
end

pcall(function()
    RunService:UnbindFromRenderStep("ShootToLockAimbot")
end)

RunService:BindToRenderStep("ShootToLockAimbot", Enum.RenderPriority.Camera.Value, function()
    if Settings.Aimbot.Enabled and Settings.Aimbot.ShootToLock and isActuallyShooting then
        local target = GetClosestPlayer()
        if target then
            Target = target
            AimAt(target)
        else
            Target = nil
        end
    else
        Target = nil
    end
end)

debugPrint("Aimbot system initialized")

-- GUI SYSTEM (STEALTH)
local existingGui = playerGui:FindFirstChild("MuslimDevGUI")
if existingGui then existingGui:Destroy() end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "GUI_" .. math.random(10000, 99999) -- Random name
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = playerGui
ProtectInstance(ScreenGui)

local mainWidth = isMobile and 280 or 300
local mainHeight = isMobile and 400 or 440

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.fromOffset(mainWidth, mainHeight)
MainFrame.Position = UDim2.fromScale(0.5, 0.5)
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.BackgroundColor3 = Theme.Dark
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local MainCorner = Instance.new("UICorner")
MainCorner.CornerRadius = UDim.new(0, 12)
MainCorner.Parent = MainFrame

local MainStroke = Instance.new("UIStroke")
MainStroke.Color = Theme.Primary
MainStroke.Thickness = 2
MainStroke.Parent = MainFrame

local TopBar = Instance.new("Frame")
TopBar.Size = UDim2.new(1, 0, 0, 40)
TopBar.BackgroundColor3 = Theme.Primary
TopBar.BorderSizePixel = 0
TopBar.Parent = MainFrame

local TopCorner = Instance.new("UICorner")
TopCorner.CornerRadius = UDim.new(0, 12)
TopCorner.Parent = TopBar

local TopFix = Instance.new("Frame")
TopFix.Size = UDim2.new(1, 0, 0, 15)
TopFix.Position = UDim2.new(0, 0, 1, -15)
TopFix.BackgroundColor3 = Theme.Primary
TopFix.BorderSizePixel = 0
TopFix.Parent = TopBar

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -50, 1, 0)
Title.Position = UDim2.fromOffset(12, 0)
Title.BackgroundTransparency = 1
Title.Font = Enum.Font.GothamBlack
Title.Text = "MUSLIMDEV"
Title.TextColor3 = Theme.TextDark
Title.TextSize = 16
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TopBar

local CloseBtn = Instance.new("TextButton")
CloseBtn.Size = UDim2.fromOffset(30, 30)
CloseBtn.Position = UDim2.new(1, -35, 0.5, 0)
CloseBtn.AnchorPoint = Vector2.new(0, 0.5)
CloseBtn.BackgroundColor3 = Theme.Dark
CloseBtn.Text = "X"
CloseBtn.TextColor3 = Theme.Primary
CloseBtn.Font = Enum.Font.GothamBlack
CloseBtn.TextSize = 16
CloseBtn.Parent = TopBar

local CloseBtnCorner = Instance.new("UICorner")
CloseBtnCorner.CornerRadius = UDim.new(1, 0)
CloseBtnCorner.Parent = CloseBtn

local ContentFrame = Instance.new("ScrollingFrame")
ContentFrame.Size = UDim2.new(1, -16, 1, -50)
ContentFrame.Position = UDim2.fromOffset(8, 45)
ContentFrame.BackgroundTransparency = 1
ContentFrame.ScrollBarThickness = 4
ContentFrame.ScrollBarImageColor3 = Theme.Primary
ContentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ContentFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
ContentFrame.Parent = MainFrame

local ContentLayout = Instance.new("UIListLayout")
ContentLayout.Padding = UDim.new(0, 6)
ContentLayout.SortOrder = Enum.SortOrder.LayoutOrder
ContentLayout.Parent = ContentFrame

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Size = UDim2.new(1, 0, 0, 25)
StatusLabel.BackgroundColor3 = Theme.DarkAlt
StatusLabel.Font = Enum.Font.GothamBold
StatusLabel.TextColor3 = Theme.Primary
StatusLabel.TextSize = 11
StatusLabel.LayoutOrder = 0
StatusLabel.Parent = ContentFrame

local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(0, 6)
StatusCorner.Parent = StatusLabel

task.spawn(function()
    while StatusLabel.Parent do
        local ping = GetPlayerPing()
        local status = isActuallyShooting and Target and ("LOCKED: " .. Target.Name:sub(1,8)) or "Ready"
        StatusLabel.Text = string.format("Ping: %.0fms | %s", ping, status)
        
        if isActuallyShooting and Target then
            StatusLabel.BackgroundColor3 = Color3.fromRGB(0, 100, 0)
            StatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        else
            StatusLabel.BackgroundColor3 = Theme.DarkAlt
            StatusLabel.TextColor3 = Theme.Primary
        end
        
        task.wait(0.1)
    end
end)

local function CreateToggle(text, getValue, setValue, order)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, 32)
    container.BackgroundColor3 = Theme.DarkAlt
    container.LayoutOrder = order
    container.Parent = ContentFrame
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = container
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.65, 0, 1, 0)
    label.Position = UDim2.fromOffset(10, 0)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.Text = text
    label.TextColor3 = Theme.Text
    label.TextSize = 11
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container
    
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.fromOffset(50, 22)
    toggleBtn.Position = UDim2.new(1, -60, 0.5, 0)
    toggleBtn.AnchorPoint = Vector2.new(0, 0.5)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 10
    toggleBtn.Parent = container
    
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 6)
    toggleCorner.Parent = toggleBtn
    
    local function updateVisual()
        local state = getValue()
        if state then
            toggleBtn.Text = "ON"
            toggleBtn.BackgroundColor3 = Theme.On
            toggleBtn.TextColor3 = Color3.new(0, 0, 0)
        else
            toggleBtn.Text = "OFF"
            toggleBtn.BackgroundColor3 = Theme.Off
            toggleBtn.TextColor3 = Color3.new(1, 1, 1)
        end
    end
    
    updateVisual()
    
    toggleBtn.Activated:Connect(function()
        setValue(not getValue())
        updateVisual()
        debugPrint(text .. " = " .. tostring(getValue()))
    end)
    
    return container
end

local function CreateSection(text, order)
    local section = Instance.new("TextLabel")
    section.Size = UDim2.new(1, 0, 0, 22)
    section.BackgroundColor3 = Theme.Primary
    section.BackgroundTransparency = 0.5
    section.Font = Enum.Font.GothamBlack
    section.Text = "  " .. text
    section.TextColor3 = Theme.Primary
    section.TextSize = 10
    section.TextXAlignment = Enum.TextXAlignment.Left
    section.LayoutOrder = order
    section.Parent = ContentFrame
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = section
    
    return section
end

CreateSection("AIMBOT", 1)
CreateToggle("Enable Aimbot", function() return Settings.Aimbot.Enabled end, function(v) Settings.Aimbot.Enabled = v end, 2)
CreateToggle("Shoot to Lock", function() return Settings.Aimbot.ShootToLock end, function(v) Settings.Aimbot.ShootToLock = v end, 3)
CreateToggle("Show FOV", function() return Settings.Aimbot.FOV.Visible end, function(v) Settings.Aimbot.FOV.Visible = v end, 4)
CreateToggle("Team Check", function() return Settings.Aimbot.Checks.Team end, function(v) Settings.Aimbot.Checks.Team = v end, 5)
CreateToggle("Wall Check", function() return Settings.Aimbot.Checks.Wall end, function(v) Settings.Aimbot.Checks.Wall = v end, 6)
CreateToggle("Hitbox Expand", function() return Settings.Aimbot.HitboxExpander.Enabled end, function(v) Settings.Aimbot.HitboxExpander.Enabled = v end, 7)

CreateSection("ESP", 8)
CreateToggle("Enable ESP", function() return Settings.ESP.Enabled end, function(v) Settings.ESP.Enabled = v end, 9)
CreateToggle("Show Boxes", function() return Settings.ESP.ShowBoxes end, function(v) Settings.ESP.ShowBoxes = v end, 10)
CreateToggle("Show Names", function() return Settings.ESP.ShowName end, function(v) Settings.ESP.ShowName = v end, 11)
CreateToggle("Show Health", function() return Settings.ESP.ShowHealth end, function(v) Settings.ESP.ShowHealth = v end, 12)

CreateSection("TRACERS", 13)
CreateToggle("Enable Tracers", function() return Settings.Tracers.Enabled end, function(v) Settings.Tracers.Enabled = v end, 14)
CreateToggle("From Center", function() return Settings.Tracers.FromCenter end, function(v) Settings.Tracers.FromCenter = v end, 15)

CreateSection("STEALTH", 16)
CreateToggle("Hide Console", 
    function() return Settings.Stealth.HideConsole end, 
    function(v) 
        Settings.Stealth.HideConsole = v 
        stealthMode = v
    end, 17)

-- DISCORD BUTTON
local DiscordBtn = Instance.new("TextButton")
DiscordBtn.Size = UDim2.new(1, 0, 0, 36)
DiscordBtn.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
DiscordBtn.Font = Enum.Font.GothamBlack
DiscordBtn.Text = "JOIN DISCORD"
DiscordBtn.TextColor3 = Color3.new(1, 1, 1)
DiscordBtn.TextSize = 12
DiscordBtn.LayoutOrder = 18
DiscordBtn.Parent = ContentFrame

local DiscordCorner = Instance.new("UICorner")
DiscordCorner.CornerRadius = UDim.new(0, 8)
DiscordCorner.Parent = DiscordBtn

DiscordBtn.Activated:Connect(function()
    OpenDiscord()
end)

debugPrint("GUI created")

CloseBtn.Activated:Connect(function()
    ScreenGui.Enabled = false
end)

local dragging = false
local dragStart, startPos

TopBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

-- MENU BUTTON
local MenuBtnGui = Instance.new("ScreenGui")
MenuBtnGui.Name = "MenuBtn_" .. math.random(1000, 9999)
MenuBtnGui.ResetOnSpawn = false
MenuBtnGui.Parent = playerGui
ProtectInstance(MenuBtnGui)

local MenuBtn = Instance.new("TextButton")
MenuBtn.Size = UDim2.fromOffset(50, 50)
MenuBtn.Position = UDim2.fromOffset(10, 120)
MenuBtn.BackgroundColor3 = Theme.Primary
MenuBtn.Text = "MD"
MenuBtn.TextColor3 = Theme.TextDark
MenuBtn.Font = Enum.Font.GothamBlack
MenuBtn.TextSize = 16
MenuBtn.Parent = MenuBtnGui

local MenuBtnCorner = Instance.new("UICorner")
MenuBtnCorner.CornerRadius = UDim.new(0, 10)
MenuBtnCorner.Parent = MenuBtn

local MenuBtnStroke = Instance.new("UIStroke")
MenuBtnStroke.Color = Theme.Dark
MenuBtnStroke.Thickness = 2
MenuBtnStroke.Parent = MenuBtn

MenuBtn.Activated:Connect(function()
    ScreenGui.Enabled = not ScreenGui.Enabled
end)

local menuDragging = false
local menuDragStart, menuStartPos

MenuBtn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        menuDragging = true
        menuDragStart = input.Position
        menuStartPos = MenuBtn.Position
    end
end)

MenuBtn.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        menuDragging = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if menuDragging and input.UserInputType == Enum.UserInputType.Touch then
        local delta = input.Position - menuDragStart
        MenuBtn.Position = UDim2.new(menuStartPos.X.Scale, menuStartPos.X.Offset + delta.X, menuStartPos.Y.Scale, menuStartPos.Y.Offset + delta.Y)
    end
end)

ScreenGui.Enabled = false

debugPrint("===================================")
debugPrint("MUSLIMDEV LOADED WITH STEALTH!")
debugPrint("Anti-Kick: ACTIVE")
debugPrint("Anti-Detection: ACTIVE")
debugPrint("GUI Protection: ACTIVE")
debugPrint("===================================")

pcall(function()
    game.StarterGui:SetCore("SendNotification", {
        Title = "MuslimDev Stealth",
        Text = "Protected & Undetected!",
        Duration = 5
    })
end)

end)

if not success then
    if not stealthMode then
        warn("Script Error: " .. tostring(errorMsg))
    end
else
    if not stealthMode then
        print("MuslimDev Loaded with Maximum Stealth!")
    end
end
