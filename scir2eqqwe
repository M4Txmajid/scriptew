--// Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

--// Config
local BRAINROT_PATH = workspace:WaitForChild("ActiveBrainrots")
local LUCKYBLOCK_PATH = workspace:WaitForChild("ActiveLuckyBlocks")
local TSUNAMI_PATH = workspace:WaitForChild("ActiveTsunamis")
local TWEEN_SPEED = 200
local TRAVEL_DEPTH = -30
local GRAB_HEIGHT = 5
local RISE_SPEED = 150
local DIVE_SPEED = 200
local WAIT_AT_TARGET = 0.3
local AUTO_LOOP = true
local PROMPT_OVERRIDE_DISTANCE = 9999
local WAVE_SAFE_DISTANCE = 120
local WAVE_CHECK_INTERVAL = 0.3
local WAVE_MAX_WAIT = 30

--// ===================== TRIAL CONFIG ===================== --
local TOWER_CFRAME = CFrame.new(4329.02148, 6.50959015, -2.42385221, 1, 0, 0, 0, 1, 0, 0, 0, 1)
local TOWER_POSITION = TOWER_CFRAME.Position
local TRIAL_TIME_LIMIT = 260
local TRIAL_COOLDOWN_WAIT = 5
local TRACKER_INTERVAL = 5
local TRIAL_BATCH_SIZE = 3

--// Detect mobile
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

--// MOBILE LIMIT: Clamp default config values for mobile
if isMobile then
    TWEEN_SPEED = math.min(TWEEN_SPEED, 100)
    TRAVEL_DEPTH = math.max(TRAVEL_DEPTH, -5)
end

--// State variables
local running = false
local activeTab = "Brainrot"
local farmingTab = "Brainrot"
local brainrotSelectedRarities = {}
local luckyBlockSelectedRarities = {}
local brainrotCheckboxes = {}
local luckyBlockCheckboxes = {}
local totalGrabbed = 0

--// Trial state
local autoTrialEnabled = false
local autoTrialRunning = false
local trialInProgress = false
local trialGrabbed = 0
local trialRequired = 0
local trialRarity = nil
local trialFolderName = nil
local trialCollecting = false

--// Rarity tracker state
local currentTrialRarity = nil
local currentTrialFolder = nil
local previousTrialRarity = nil
local rarityChangeCount = 0
local lastScanResult = nil
local lastScanFolder = nil

--// Continuous tracker state
local continuousTrackerRunning = false
local trackerScanCount = 0

--// Auto-select state
local savedTrialSelections = {}
local savedTrialTab = nil
local trialAutoSelected = false

--// ===================== RARITY KEYWORDS (ordered by priority) ===================== --
local RARITY_KEYWORDS = {
    "divine", "secret", "mythical", "mythic", "legendary",
    "epic", "rare", "uncommon", "common"
}

--// ===================== TOWER PATH HELPERS ===================== --

local function getInfoFrame()
    local ok, info = pcall(function() return workspace.GameObjects.PlaceSpecific.root.Tower.Main.Billboard.BillboardGui.Frame.Info end)
    return ok and info or nil
end

local function getTrialTimerContainer()
    local info = getInfoFrame()
    return info and info:FindFirstChild("TrialTimerContainer") or nil
end

local function getCooldownContainer()
    local info = getInfoFrame()
    return info and info:FindFirstChild("CooldownContainer") or nil
end

local function getProximityPrompt()
    local ok, p = pcall(function() return workspace.GameObjects.PlaceSpecific.root.Tower.Main.Prompt.ProximityPrompt end)
    return (ok and p and p:IsA("ProximityPrompt")) and p or nil
end

--// ===================== IMPROVED BILLBOARD SCANNER ===================== --

local function extractRarityFromText(text)
    if not text or #text == 0 then return nil, nil end
    local lower = string.lower(text)
    if string.find(lower, "time remaining") then return nil, nil end
    if string.find(lower, "cooldown") then return nil, nil end
    if string.find(lower, "seconds left") then return nil, nil end
    if string.find(lower, "minutes left") then return nil, nil end
    if string.find(lower, "waiting") and not string.find(lower, "bring") then return nil, nil end
    if lower:match("^%s*%d+%s*$") then return nil, nil end
    if lower:match("^%s*%d+:%d+%s*$") then return nil, nil end
    for _, keyword in ipairs(RARITY_KEYWORDS) do
        if string.find(lower, keyword) then
            local count = nil
            count = count or tonumber(lower:match("(%d+)%s+" .. keyword))
            count = count or tonumber(lower:match(keyword .. "%s*x?(%d+)"))
            count = count or tonumber(lower:match("x(%d+)"))
            count = count or tonumber(lower:match("%((%d+)%)"))
            if not count then
                for num in lower:gmatch("(%d+)") do
                    local n = tonumber(num)
                    if n and n >= 1 and n <= 50 then count = n; break end
                end
            end
            return keyword, count or 1
        end
    end
    return nil, nil
end

local function scanTrialFromBillboard()
    local debugParts = {}
    local info = getInfoFrame()
    if info then
        local bestMatch = nil
        local bestPriority = 999
        for _, desc in pairs(info:GetDescendants()) do
            if (desc:IsA("TextLabel") or desc:IsA("TextButton") or desc:IsA("TextBox")) then
                local text = desc.Text
                if text and #text > 1 then
                    local lower = string.lower(text)
                    table.insert(debugParts, string.format("[%s]%s", desc.Name, text))
                    local isTimer = false
                    local parent = desc.Parent
                    while parent and parent ~= info do
                        local pn = string.lower(parent.Name)
                        if string.find(pn, "timer") or string.find(pn, "cooldown") or string.find(pn, "countdown") then isTimer = true; break end
                        parent = parent.Parent
                    end
                    if isTimer then continue end
                    if lower:match("^%s*%d+%s*$") then continue end
                    if lower:match("^%s*%d+:%d+") then continue end
                    if string.find(lower, "time") and string.find(lower, "%d") and not string.find(lower, "bring") then continue end
                    local r, c = extractRarityFromText(text)
                    if r then
                        local priority = 50
                        if string.find(lower, "bring") then priority = 1 end
                        if string.find(lower, "collect") then priority = 2 end
                        if string.find(lower, "deliver") then priority = 3 end
                        if string.find(lower, "need") then priority = 4 end
                        if string.find(lower, "gather") then priority = 5 end
                        if string.find(lower, "find") then priority = 6 end
                        if string.find(lower, "get") then priority = 7 end
                        if priority < bestPriority then bestPriority = priority; bestMatch = {rarity = r, count = c, text = text, source = "billboard"} end
                    end
                end
            end
        end
        if bestMatch then return bestMatch.rarity, bestMatch.count, bestMatch.text, table.concat(debugParts, " | ") end
    end
    local playerGui = player:FindFirstChild("PlayerGui")
    if playerGui then
        local bestMatch = nil
        local bestPriority = 999
        for _, desc in pairs(playerGui:GetDescendants()) do
            if (desc:IsA("TextLabel") or desc:IsA("TextButton")) and desc.Visible then
                local text = desc.Text
                if text and #text > 2 then
                    local lower = string.lower(text)
                    local isTrialRelated = false
                    if string.find(lower, "trial") then isTrialRelated = true end
                    if string.find(lower, "bring") then isTrialRelated = true end
                    if string.find(lower, "collect") then isTrialRelated = true end
                    if string.find(lower, "tsunami") then isTrialRelated = true end
                    if string.find(lower, "deliver") then isTrialRelated = true end
                    if string.find(lower, "need") and string.find(lower, "brainrot") then isTrialRelated = true end
                    if not isTrialRelated then
                        local p = desc.Parent
                        while p and p ~= playerGui do
                            local pn = string.lower(p.Name)
                            if string.find(pn, "trial") or string.find(pn, "tsunami") or string.find(pn, "tower") or string.find(pn, "quest") then isTrialRelated = true; break end
                            p = p.Parent
                        end
                    end
                    if isTrialRelated then
                        local r, c = extractRarityFromText(text)
                        if r then
                            local priority = 50
                            if string.find(lower, "bring") then priority = 1 end
                            if string.find(lower, "collect") then priority = 2 end
                            if string.find(lower, "deliver") then priority = 3 end
                            if string.find(lower, "need") then priority = 4 end
                            if priority < bestPriority then bestPriority = priority; bestMatch = {rarity = r, count = c, text = text} end
                        end
                    end
                end
            end
        end
        if bestMatch then return bestMatch.rarity, bestMatch.count, bestMatch.text, table.concat(debugParts, " | ") .. " [GUI]" end
    end
    return nil, nil, nil, table.concat(debugParts, " | ") .. " [NONE]"
end

local function scanWithRetry(maxAttempts, delayBetween)
    maxAttempts = maxAttempts or 5; delayBetween = delayBetween or 0.4
    local results = {}
    for i = 1, maxAttempts do
        if not autoTrialEnabled then return nil, nil, nil, "stopped" end
        local r, c, t, d = scanTrialFromBillboard()
        if r then results[r] = (results[r] or 0) + 1; if results[r] >= 2 then return r, c, t, d end end
        if i < maxAttempts then task.wait(delayBetween) end
    end
    for i = 1, maxAttempts do
        local r, c, t, d = scanTrialFromBillboard()
        if r then return r, c, t, d end; task.wait(0.2)
    end
    return nil, nil, nil, "no_result_after_retry"
end

--// ===================== TRIAL STATE DETECTION ===================== --

local function isTrialOnCooldown()
    local cooldown = getCooldownContainer()
    if not cooldown then return false, "" end
    local visible = true; pcall(function() visible = cooldown.Visible end)
    if not visible then return false, "" end
    local cdText = ""
    for _, desc in pairs(cooldown:GetDescendants()) do
        if desc:IsA("TextLabel") and desc.Visible and desc.Text and #desc.Text > 0 then cdText = cdText .. " " .. desc.Text end
    end
    return #cdText > 0, cdText
end

local function isTrialTimerActive()
    local timer = getTrialTimerContainer()
    if not timer then return false, "" end
    local visible = true; pcall(function() visible = timer.Visible end)
    if not visible then return false, "" end
    local timerText = ""
    for _, desc in pairs(timer:GetDescendants()) do
        if desc:IsA("TextLabel") and desc.Visible and desc.Text and #desc.Text > 0 then timerText = timerText .. " " .. desc.Text end
    end
    if #timerText > 0 and string.find(timerText, "%d") then return true, timerText end
    return false, ""
end

--// ===================== MATCH RARITY TO FOLDER ===================== --

local function matchRarityToFolder(keyword)
    if not keyword then return nil end
    local lower = string.lower(keyword)
    for _, child in pairs(BRAINROT_PATH:GetChildren()) do
        if (child:IsA("Folder") or child:IsA("Model")) then
            if string.lower(child.Name) == lower then return child.Name end
        end
    end
    for _, child in pairs(BRAINROT_PATH:GetChildren()) do
        if (child:IsA("Folder") or child:IsA("Model")) then
            local cn = string.lower(child.Name)
            if string.find(cn, lower) or string.find(lower, cn) then return child.Name end
        end
    end
    if #lower > 4 then
        local short = lower:sub(1, -3)
        for _, child in pairs(BRAINROT_PATH:GetChildren()) do
            if (child:IsA("Folder") or child:IsA("Model")) then
                local cn = string.lower(child.Name)
                if string.find(cn, short) or string.find(short, cn) then return child.Name end
            end
        end
    end
    return nil
end

--// ===================== AUTO-SELECT FUNCTIONS ===================== --

local function saveCurrentSelections()
    savedTrialSelections = {}
    for name, val in pairs(brainrotSelectedRarities) do savedTrialSelections[name] = val end
    savedTrialTab = activeTab; trialAutoSelected = true
end

local function autoSelectTrialRarity(folderName)
    for name, data in pairs(brainrotCheckboxes) do
        brainrotSelectedRarities[name] = nil; data.Check.Text = ""; data.Check.BackgroundColor3 = Color3.fromRGB(50, 50, 70); data.Check.TextColor3 = Color3.fromRGB(100, 255, 100)
    end
    if brainrotCheckboxes[folderName] then
        brainrotSelectedRarities[folderName] = true
        brainrotCheckboxes[folderName].Check.Text = "★"; brainrotCheckboxes[folderName].Check.BackgroundColor3 = Color3.fromRGB(0, 160, 255); brainrotCheckboxes[folderName].Check.TextColor3 = Color3.fromRGB(255, 255, 0)
        return true
    end
    return false
end

local function restorePreviousSelections()
    if not trialAutoSelected then return end
    for name, data in pairs(brainrotCheckboxes) do
        brainrotSelectedRarities[name] = nil; data.Check.Text = ""; data.Check.BackgroundColor3 = Color3.fromRGB(50, 50, 70); data.Check.TextColor3 = Color3.fromRGB(100, 255, 100)
    end
    for name, val in pairs(savedTrialSelections) do
        if val and brainrotCheckboxes[name] then
            brainrotSelectedRarities[name] = true; brainrotCheckboxes[name].Check.Text = "Y"; brainrotCheckboxes[name].Check.BackgroundColor3 = Color3.fromRGB(40, 100, 40)
        end
    end
    savedTrialSelections = {}; trialAutoSelected = false
end

--// ===================== RARITY TRACKER ===================== --

local function resetRarityTracker()
    previousTrialRarity = nil; currentTrialRarity = nil; currentTrialFolder = nil
    lastScanResult = nil; lastScanFolder = nil; rarityChangeCount = 0; trackerScanCount = 0
end

local function trackerRescanAtTower()
    task.wait(0.5)
    local newRarity, newCount, sourceText, debugInfo = scanWithRetry(4, 0.3)
    if not newRarity then
        task.wait(0.5); newRarity, newCount, sourceText, debugInfo = scanWithRetry(3, 0.5)
        if not newRarity then return nil, nil, "completed", debugInfo end
    end
    local newFolder = matchRarityToFolder(newRarity)
    if not newFolder then return newRarity, newCount, "no_folder", debugInfo end
    lastScanResult = newRarity; lastScanFolder = newFolder
    if currentTrialRarity and newRarity ~= currentTrialRarity then
        previousTrialRarity = currentTrialRarity; currentTrialRarity = newRarity; currentTrialFolder = newFolder; rarityChangeCount = rarityChangeCount + 1
        autoSelectTrialRarity(newFolder)
        return newRarity, newCount, "changed", debugInfo
    end
    currentTrialRarity = newRarity; currentTrialFolder = newFolder
    return newRarity, newCount, "same", debugInfo
end

--// ===================== CONTINUOUS BACKGROUND TRACKER ===================== --

local function startContinuousTracker()
    if continuousTrackerRunning then return end
    continuousTrackerRunning = true; trackerScanCount = 0
    task.spawn(function()
        while autoTrialEnabled and continuousTrackerRunning do
            if trialInProgress and trialCollecting and currentTrialRarity then
                trackerScanCount = trackerScanCount + 1
                local newRarity, newCount, sourceText, debugInfo = scanTrialFromBillboard()
                if newRarity then
                    local newFolder = matchRarityToFolder(newRarity)
                    if newFolder and currentTrialRarity and newRarity ~= currentTrialRarity then
                        previousTrialRarity = currentTrialRarity; currentTrialRarity = newRarity; currentTrialFolder = newFolder
                        rarityChangeCount = rarityChangeCount + 1; trialRequired = newCount or 1
                        autoSelectTrialRarity(newFolder)
                        TrialCollectLabel.Text = string.format("⚡SWAP: %s→%s⚡", previousTrialRarity or "?", currentTrialFolder)
                        TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
                        TrialDetailLabel.Text = string.format("★Need: %d %s (#%d)", newCount or 1, currentTrialFolder, rarityChangeCount)
                        TrialDetailLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
                        TrialDebugLabel.Text = string.format("LIVE #%d: %s→%s", trackerScanCount, previousTrialRarity or "?", currentTrialRarity)
                    elseif newFolder and newRarity == currentTrialRarity then
                        if newCount and newCount ~= trialRequired then
                            trialRequired = newCount
                            TrialProgressLabel.Text = string.format("Got:%d Need:%d %s", trialGrabbed, trialRequired, currentTrialFolder)
                        end
                        TrialDebugLabel.Text = string.format("#%d: ✓%s", trackerScanCount, currentTrialRarity)
                    end
                    lastScanResult = newRarity; lastScanFolder = newFolder
                else
                    TrialDebugLabel.Text = string.format("#%d: no result", trackerScanCount)
                end
                updateTrackerLabel(); updateTrialTimerDisplay()
            end
            for i = 1, math.floor(TRACKER_INTERVAL / 0.5) do
                if not autoTrialEnabled or not continuousTrackerRunning then break end; task.wait(0.5)
            end
        end
        continuousTrackerRunning = false
    end)
end

local function stopContinuousTracker() continuousTrackerRunning = false end

--// ===================== TSUNAMI DETECTION ===================== --

local function getTsunamiParts()
    local parts = {}
    if not TSUNAMI_PATH or not TSUNAMI_PATH.Parent then return parts end
    for _, obj in pairs(TSUNAMI_PATH:GetDescendants()) do if obj:IsA("BasePart") then table.insert(parts, obj) end end
    return parts
end

local function getClosestWaveDistance(position)
    local closest = math.huge
    for _, part in pairs(getTsunamiParts()) do
        if part and part.Parent then local dist = (part.Position - position).Magnitude; if dist < closest then closest = dist end end
    end
    return closest
end

local function isWaveNearby(position, safeDistance) return getClosestWaveDistance(position) < (safeDistance or WAVE_SAFE_DISTANCE) end

local function isWaveApproaching(targetPos, checkRadius)
    checkRadius = checkRadius or WAVE_SAFE_DISTANCE * 1.5
    for _, part in pairs(getTsunamiParts()) do
        if part and part.Parent then if (part.Position - targetPos).Magnitude < checkRadius then return true end end
    end
    return false
end

local function waitForWavesToClear(targetPos, statusCallback)
    local startTime = tick()
    while true do
        if not isWaveApproaching(targetPos, WAVE_SAFE_DISTANCE) then return true end
        if tick() - startTime > WAVE_MAX_WAIT then return true end
        if statusCallback then statusCallback("Wave nearby - waiting...") end
        task.wait(WAVE_CHECK_INTERVAL)
        if not running and not autoTrialRunning then return false end
    end
end

--// ===================== SAVED POSITION ===================== --

local savedPosition, savedCFrame = nil, nil
local function saveCurrentPosition()
    if rootPart and rootPart.Parent then savedCFrame = rootPart.CFrame; savedPosition = rootPart.Position; return true end
    return false
end

--// ===================== ANTI-PHYSICS ===================== --

local bodyVel, bodyGyro = nil, nil
local physicsLocked = false
local frameConn = nil
local savedWalkSpeed, savedJumpPower = 16, 50

local function lockPhysics()
    if physicsLocked then return end
    if not rootPart or not rootPart.Parent then return end
    physicsLocked = true
    savedWalkSpeed = humanoid.WalkSpeed; savedJumpPower = humanoid.JumpPower
    humanoid.WalkSpeed = 0; humanoid.JumpPower = 0
    pcall(function() humanoid.JumpHeight = 0 end)
    for _, s in ipairs({Enum.HumanoidStateType.Swimming, Enum.HumanoidStateType.Freefall,
        Enum.HumanoidStateType.FallingDown, Enum.HumanoidStateType.Ragdoll,
        Enum.HumanoidStateType.GettingUp, Enum.HumanoidStateType.Jumping,
        Enum.HumanoidStateType.Landed, Enum.HumanoidStateType.Climbing}) do
        pcall(function() humanoid:SetStateEnabled(s, false) end)
    end
    pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Physics) end)
    for _, obj in pairs(rootPart:GetChildren()) do if obj.Name == "_BrainLock" then obj:Destroy() end end
    bodyVel = Instance.new("BodyVelocity"); bodyVel.Name = "_BrainLock"
    bodyVel.Velocity = Vector3.zero; bodyVel.MaxForce = Vector3.new(1e9,1e9,1e9); bodyVel.P = 1e9; bodyVel.Parent = rootPart
    bodyGyro = Instance.new("BodyGyro"); bodyGyro.Name = "_BrainLock"
    bodyGyro.CFrame = rootPart.CFrame; bodyGyro.MaxTorque = Vector3.new(1e9,1e9,1e9); bodyGyro.P = 1e9; bodyGyro.Parent = rootPart
    if frameConn then frameConn:Disconnect() end
    frameConn = RunService.Heartbeat:Connect(function()
        if not rootPart or not rootPart.Parent then return end
        rootPart.Velocity = Vector3.zero; rootPart.AssemblyLinearVelocity = Vector3.zero; rootPart.AssemblyAngularVelocity = Vector3.zero
        if bodyGyro and bodyGyro.Parent then bodyGyro.CFrame = rootPart.CFrame end
    end)
end

local function unlockPhysics()
    physicsLocked = false
    if frameConn then frameConn:Disconnect(); frameConn = nil end
    if bodyVel and bodyVel.Parent then bodyVel:Destroy() end
    if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
    bodyVel, bodyGyro = nil, nil
    if rootPart and rootPart.Parent then
        for _, obj in pairs(rootPart:GetChildren()) do if obj.Name == "_BrainLock" then obj:Destroy() end end
    end
    if humanoid then
        humanoid.WalkSpeed = savedWalkSpeed; humanoid.JumpPower = savedJumpPower
        pcall(function() humanoid.JumpHeight = 7.2 end)
        for _, s in ipairs({Enum.HumanoidStateType.Swimming, Enum.HumanoidStateType.Freefall,
            Enum.HumanoidStateType.FallingDown, Enum.HumanoidStateType.Ragdoll,
            Enum.HumanoidStateType.GettingUp, Enum.HumanoidStateType.Jumping,
            Enum.HumanoidStateType.Landed, Enum.HumanoidStateType.Climbing, Enum.HumanoidStateType.Running}) do
            pcall(function() humanoid:SetStateEnabled(s, true) end)
        end
        pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
    end
end

--// ===================== SMOOTH TWEEN ===================== --

local currentTween, tweening = nil, false

local function smoothTween(targetCFrame, speed)
    if not rootPart or not rootPart.Parent then return false end
    local distance = (rootPart.Position - targetCFrame.Position).Magnitude
    if distance < 1 then rootPart.CFrame = targetCFrame; return true end
    local tweenTime = math.max(distance / speed, 0.05)
    if bodyVel and bodyVel.Parent then bodyVel.MaxForce = Vector3.zero end
    rootPart.Velocity = Vector3.zero; rootPart.AssemblyLinearVelocity = Vector3.zero; rootPart.AssemblyAngularVelocity = Vector3.zero
    local guard = RunService.Heartbeat:Connect(function()
        if not rootPart or not rootPart.Parent then return end
        rootPart.Velocity = Vector3.zero; rootPart.AssemblyLinearVelocity = Vector3.zero; rootPart.AssemblyAngularVelocity = Vector3.zero
        pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Physics) end)
    end)
    currentTween = TweenService:Create(rootPart, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {CFrame = targetCFrame})
    tweening = true; currentTween:Play(); currentTween.Completed:Wait(); tweening = false
    guard:Disconnect()
    rootPart.CFrame = targetCFrame; rootPart.Velocity = Vector3.zero; rootPart.AssemblyLinearVelocity = Vector3.zero; rootPart.AssemblyAngularVelocity = Vector3.zero
    if bodyVel and bodyVel.Parent then bodyVel.Velocity = Vector3.zero; bodyVel.MaxForce = Vector3.new(1e9,1e9,1e9) end
    return true
end

local function stopTween()
    if currentTween then currentTween:Cancel(); currentTween = nil; tweening = false end
    if bodyVel and bodyVel.Parent then bodyVel.Velocity = Vector3.zero; bodyVel.MaxForce = Vector3.new(1e9,1e9,1e9) end
end

--// ===================== NOCLIP ===================== --

local noclipEnabled, noclipConnection = false, nil
local function enableNoclip()
    if noclipConnection then return end; noclipEnabled = true
    noclipConnection = RunService.Stepped:Connect(function()
        if not character or not character.Parent then return end
        for _, p in pairs(character:GetDescendants()) do if p:IsA("BasePart") then p.CanCollide = false end end
    end)
end
local function disableNoclip()
    noclipEnabled = false; if noclipConnection then noclipConnection:Disconnect(); noclipConnection = nil end
end

--// ===================== RETURN TO SAVED ===================== --

local function returnToSaved(useSmooth, depthOverride)
    if not savedCFrame or not rootPart or not rootPart.Parent then return false end
    local useDepth = depthOverride or TRAVEL_DEPTH
    if useSmooth then
        smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y + useDepth, rootPart.Position.Z), DIVE_SPEED)
        task.wait(0.05)
        smoothTween(CFrame.new(savedCFrame.Position.X, savedCFrame.Position.Y + useDepth, savedCFrame.Position.Z), TWEEN_SPEED)
        task.wait(0.05)
        waitForWavesToClear(savedCFrame.Position, function() end)
        smoothTween(savedCFrame, RISE_SPEED)
    else
        rootPart.CFrame = savedCFrame; rootPart.Velocity = Vector3.zero
    end
    return true
end
--// ===================== PROXIMITY PROMPT ===================== --

local function fireProximityPrompt(prompt)
    if not prompt or not prompt:IsA("ProximityPrompt") then return end
    local oh, od, oe, ox = prompt.HoldDuration, prompt.MaxActivationDistance, prompt.Enabled, prompt.Exclusivity
    prompt.HoldDuration = 0; prompt.MaxActivationDistance = PROMPT_OVERRIDE_DISTANCE; prompt.Enabled = true
    prompt.Exclusivity = Enum.ProximityPromptExclusivity.AlwaysShow
    prompt:InputHoldBegin(); prompt:InputHoldEnd()
    task.delay(0.1, function()
        if prompt and prompt.Parent then prompt.HoldDuration = oh; prompt.MaxActivationDistance = od; prompt.Enabled = oe; prompt.Exclusivity = ox end
    end)
end

local function grabAllPrompts(object)
    if not object or not object.Parent then return 0 end
    local count = 0
    if object:IsA("ProximityPrompt") then fireProximityPrompt(object); count += 1 end
    for _, d in pairs(object:GetDescendants()) do if d:IsA("ProximityPrompt") then fireProximityPrompt(d); count += 1 end end
    if object.Parent then
        for _, c in pairs(object.Parent:GetChildren()) do if c:IsA("ProximityPrompt") then fireProximityPrompt(c); count += 1 end end
    end
    return count
end

local function grabNearbyPrompts(position, radius)
    radius = radius or 20; local count = 0
    for _, d in pairs(workspace:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            local p = d.Parent
            if p and p:IsA("BasePart") and (p.Position - position).Magnitude <= radius then fireProximityPrompt(d); count += 1 end
        end
    end
    return count
end

local autoInstantEnabled = false
local promptConnections = {}
local function enableAutoInstantPrompts()
    autoInstantEnabled = true
    for _, d in pairs(workspace:GetDescendants()) do
        if d:IsA("ProximityPrompt") then d.HoldDuration = 0; d.MaxActivationDistance = math.max(d.MaxActivationDistance, 15) end
    end
    promptConnections[#promptConnections+1] = workspace.DescendantAdded:Connect(function(d)
        if autoInstantEnabled and d:IsA("ProximityPrompt") then task.wait(); d.HoldDuration = 0; d.MaxActivationDistance = math.max(d.MaxActivationDistance, 15) end
    end)
end
local function disableAutoInstantPrompts()
    autoInstantEnabled = false; for _, c in pairs(promptConnections) do c:Disconnect() end; promptConnections = {}
end

--// ===================== REFRESH CHAR ===================== --

local function refreshChar()
    if not character or not character.Parent then
        character = player.Character or player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid"); rootPart = character:WaitForChild("HumanoidRootPart")
        task.wait(0.3); enableNoclip(); lockPhysics()
    end
    if not bodyVel or not bodyVel.Parent or not bodyGyro or not bodyGyro.Parent then lockPhysics() end
end

--// ===================== TOWER TRAVEL ===================== --

local function travelToTower()
    refreshChar(); enableNoclip(); lockPhysics()
    smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y + TRAVEL_DEPTH, rootPart.Position.Z), DIVE_SPEED)
    task.wait(0.05)
    smoothTween(CFrame.new(TOWER_POSITION.X, TOWER_POSITION.Y + TRAVEL_DEPTH, TOWER_POSITION.Z), TWEEN_SPEED)
    task.wait(0.05)
    smoothTween(CFrame.new(TOWER_POSITION.X, TOWER_POSITION.Y + GRAB_HEIGHT, TOWER_POSITION.Z), RISE_SPEED)
    task.wait(0.15)
    rootPart.CFrame = TOWER_CFRAME * CFrame.new(0, 3, 4)
    rootPart.Velocity = Vector3.zero; rootPart.AssemblyLinearVelocity = Vector3.zero
    task.wait(0.1)
    return true
end

local function fireTrialPrompt()
    local prompt = getProximityPrompt()
    if not prompt then return false end
    rootPart.CFrame = TOWER_CFRAME * CFrame.new(0, 3, 4)
    rootPart.Velocity = Vector3.zero
    task.wait(0.1)
    fireProximityPrompt(prompt); task.wait(0.3); fireProximityPrompt(prompt); task.wait(0.2)
    return true
end

--// ===================== SCANNER ===================== --

local function scanRarityFolders()
    local f = {}; for _, c in pairs(BRAINROT_PATH:GetChildren()) do if c:IsA("Folder") or c:IsA("Model") then table.insert(f, c.Name) end end
    table.sort(f); return f
end

local function getBrainrots(selRarities)
    local b = {}
    for _, rn in pairs(selRarities) do
        local folder = BRAINROT_PATH:FindFirstChild(rn)
        if folder then
            for _, br in pairs(folder:GetChildren()) do
                local p = br:IsA("Model") and (br.PrimaryPart or br:FindFirstChildWhichIsA("BasePart")) or (br:IsA("BasePart") and br or nil)
                if p then table.insert(b, {Name=br.Name, Rarity=rn, Part=p, Object=br}) end
            end
        end
    end
    return b
end

local function scanLuckyBlockRarities()
    local r, s = {}, {}; for _, c in pairs(LUCKYBLOCK_PATH:GetChildren()) do
        local ra = c.Name:match("_(%w+)$"); if ra and not s[ra] then s[ra]=true; table.insert(r, ra) end
    end; table.sort(r); return r
end

local function getLuckyBlockRarityCount(rarity)
    local c = 0; for _, ch in pairs(LUCKYBLOCK_PATH:GetChildren()) do if ch.Name:match("_(%w+)$") == rarity then c+=1 end end; return c
end

local function getLuckyBlocks(selR)
    local b = {}; for _, c in pairs(LUCKYBLOCK_PATH:GetChildren()) do
        local r = c.Name:match("_(%w+)$"); if r and selR[r] then
            local p = c:IsA("Model") and (c.PrimaryPart or c:FindFirstChildWhichIsA("BasePart")) or (c:IsA("BasePart") and c or nil)
            if p then table.insert(b, {Name=c.Name, Rarity=r, Part=p, Object=c}) end
        end
    end; return b
end

local function hasSelectedRarities(tab)
    tab = tab or activeTab
    if tab == "Brainrot" then for _ in pairs(brainrotSelectedRarities) do return true end
    else for _ in pairs(luckyBlockSelectedRarities) do return true end end
    return false
end

local function getTargets(tab)
    tab = tab or activeTab
    if tab == "Brainrot" then
        local sel = {}; for n in pairs(brainrotSelectedRarities) do table.insert(sel, n) end
        return #sel > 0 and getBrainrots(sel) or {}
    else return getLuckyBlocks(luckyBlockSelectedRarities) end
end

--// ===================== GUI SETUP ===================== --

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "BrainrotTP"; ScreenGui.ResetOnSpawn = false; ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
pcall(function() ScreenGui.Parent = game:GetService("CoreGui") end)
if not ScreenGui.Parent then ScreenGui.Parent = player:WaitForChild("PlayerGui") end

local guiWidth = isMobile and 200 or 310
local guiHeight = isMobile and 400 or 720
local fontSize = isMobile and 8 or 12
local btnHeight = isMobile and 26 or 34
local checkHeight = isMobile and 24 or 32
local sliderH = isMobile and 8 or 10
local toggleH = isMobile and 22 or 28
local dragH = isMobile and 30 or 40

local MainFrame = Instance.new("Frame"); MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, guiWidth, 0, guiHeight)
MainFrame.Position = UDim2.new(0.5, -guiWidth/2, 0.5, -guiHeight/2)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35); MainFrame.BorderSizePixel = 0
MainFrame.Active = true; MainFrame.Parent = ScreenGui
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
local uiStroke = Instance.new("UIStroke", MainFrame); uiStroke.Color = Color3.fromRGB(100, 60, 200); uiStroke.Thickness = 2

local dragBar = Instance.new("Frame"); dragBar.Size = UDim2.new(1, 0, 0, dragH)
dragBar.BackgroundColor3 = Color3.fromRGB(40, 20, 80); dragBar.BorderSizePixel = 0; dragBar.Parent = MainFrame
Instance.new("UICorner", dragBar).CornerRadius = UDim.new(0, 10)
local dragActive, dragStartInput, startPos = false, nil, nil
dragBar.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then dragActive=true; dragStartInput=i.Position; startPos=MainFrame.Position end end)
UserInputService.InputChanged:Connect(function(i) if dragActive and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then local d=i.Position-dragStartInput; MainFrame.Position=UDim2.new(startPos.X.Scale, startPos.X.Offset+d.X, startPos.Y.Scale, startPos.Y.Offset+d.Y) end end)
UserInputService.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then dragActive=false end end)

local Title = Instance.new("TextLabel"); Title.Size = UDim2.new(1, -80, 1, 0); Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1; Title.Text = "Brainrot TP"; Title.TextColor3 = Color3.new(1,1,1)
Title.TextSize = isMobile and 11 or 16; Title.Font = Enum.Font.GothamBold; Title.TextXAlignment = Enum.TextXAlignment.Left; Title.Parent = dragBar

local minimized = false
local minBtnW = isMobile and 26 or 34
local minBtnH = isMobile and 20 or 28
local MinBtn = Instance.new("TextButton"); MinBtn.Size = UDim2.new(0, minBtnW, 0, minBtnH)
MinBtn.Position = UDim2.new(1, -(minBtnW*2+4), 0, isMobile and 5 or 6)
MinBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 100); MinBtn.BorderSizePixel = 0; MinBtn.Text = "_"
MinBtn.TextColor3 = Color3.new(1,1,1); MinBtn.TextSize = isMobile and 12 or 16; MinBtn.Font = Enum.Font.GothamBold; MinBtn.Parent = dragBar
Instance.new("UICorner", MinBtn).CornerRadius = UDim.new(0, 6)
local CloseBtn = Instance.new("TextButton"); CloseBtn.Size = UDim2.new(0, minBtnW, 0, minBtnH)
CloseBtn.Position = UDim2.new(1, -(minBtnW+2), 0, isMobile and 5 or 6)
CloseBtn.BackgroundColor3 = Color3.fromRGB(160, 30, 30); CloseBtn.BorderSizePixel = 0; CloseBtn.Text = "X"
CloseBtn.TextColor3 = Color3.new(1,1,1); CloseBtn.TextSize = isMobile and 10 or 14; CloseBtn.Font = Enum.Font.GothamBold; CloseBtn.Parent = dragBar
Instance.new("UICorner", CloseBtn).CornerRadius = UDim.new(0, 6)

local contentFrame = Instance.new("ScrollingFrame"); contentFrame.Name = "Content"
contentFrame.Size = UDim2.new(1, 0, 1, -dragH); contentFrame.Position = UDim2.new(0, 0, 0, dragH)
contentFrame.BackgroundTransparency = 1; contentFrame.BorderSizePixel = 0; contentFrame.ScrollBarThickness = isMobile and 3 or 4
contentFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 60, 200); contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
contentFrame.ElasticBehavior = Enum.ElasticBehavior.Always; contentFrame.ScrollingDirection = Enum.ScrollingDirection.Y
contentFrame.Parent = MainFrame

MinBtn.MouseButton1Click:Connect(function()
    minimized = not minimized; contentFrame.Visible = not minimized
    MainFrame.Size = minimized and UDim2.new(0, guiWidth, 0, dragH) or UDim2.new(0, guiWidth, 0, guiHeight)
    MinBtn.Text = minimized and "+" or "_"
end)
CloseBtn.MouseButton1Click:Connect(function() ScreenGui:Destroy() end)

--// ===================== CONTENT LAYOUT ===================== --

local yOff = 4
local lh = isMobile and 11 or 16
local lhs = isMobile and 10 or 14
local lhx = isMobile and 9 or 12

local function makeLabel(text, height, color, fSize)
    local l = Instance.new("TextLabel"); l.Size = UDim2.new(1, -16, 0, height); l.Position = UDim2.new(0, 8, 0, yOff)
    l.BackgroundTransparency = 1; l.Text = text; l.TextColor3 = color or Color3.fromRGB(180,180,180)
    l.TextSize = fSize or fontSize; l.Font = Enum.Font.Gotham; l.TextXAlignment = Enum.TextXAlignment.Left
    l.TextWrapped = true; l.Parent = contentFrame; yOff = yOff + height + 2; return l
end

local StatusLabel = makeLabel("Status: Idle", lh, Color3.fromRGB(180,180,180))
local PhaseLabel = makeLabel("Phase: --", lhs, Color3.fromRGB(100,180,255), fontSize-1)
local WaveLabel = makeLabel("Waves: Safe", lhs, Color3.fromRGB(100,255,100), fontSize-1)
local GrabLabel = makeLabel("Grabbed: 0", lhs, Color3.fromRGB(100,255,100))

local TrialHeader = makeLabel("═══ TRIAL ═══", lh, Color3.fromRGB(0,200,255))
local TrialStatusLabel = makeLabel("Trial: OFF", lh, Color3.fromRGB(180,180,180))
local TrialDetailLabel = makeLabel("Requirement: --", lhs, Color3.fromRGB(0,200,255), fontSize-1)
local TrialCollectLabel = makeLabel("Collecting: --", lhs, Color3.fromRGB(255,255,0), fontSize-1)
local TrialTrackerLabel = makeLabel("Tracker: Idle", lhs, Color3.fromRGB(255,150,255), fontSize-1)
local TrialProgressLabel = makeLabel("Progress: 0/0", lhs, Color3.fromRGB(0,255,100), fontSize-1)
local TrialDebugLabel = makeLabel("Debug: --", lhx, Color3.fromRGB(120,120,150), fontSize-2)

local SavedPosLabel = makeLabel("Saved Pos: None", lhx, Color3.fromRGB(255,180,80), fontSize-2)

local function updateSavedPosLabel()
    if savedCFrame then
        local p = savedCFrame.Position
        SavedPosLabel.Text = string.format("Saved: X:%.0f Y:%.0f Z:%.0f", p.X, p.Y, p.Z)
        SavedPosLabel.TextColor3 = Color3.fromRGB(100,255,180)
    else SavedPosLabel.Text = "Saved Pos: None"; SavedPosLabel.TextColor3 = Color3.fromRGB(255,180,80) end
end

local function updateTrackerLabel()
    if currentTrialRarity and currentTrialFolder then
        local changeInfo = ""
        if rarityChangeCount > 0 then
            changeInfo = string.format(" |S:%d", rarityChangeCount)
            if previousTrialRarity then changeInfo = changeInfo .. string.format("(%s)", previousTrialRarity) end
        end
        local scanInfo = ""
        if trackerScanCount > 0 then scanInfo = string.format(" [#%d]", trackerScanCount) end
        TrialTrackerLabel.Text = string.format("★%s★%s%s", currentTrialFolder, changeInfo, scanInfo)
        TrialTrackerLabel.TextColor3 = Color3.fromRGB(0, 255, 200)
    else
        TrialTrackerLabel.Text = "Tracker: Waiting..."
        TrialTrackerLabel.TextColor3 = Color3.fromRGB(255, 150, 255)
    end
end

local function updateWaveStatus(pos)
    local dist = getClosestWaveDistance(pos or (rootPart and rootPart.Position or Vector3.zero))
    if dist < WAVE_SAFE_DISTANCE then WaveLabel.Text = string.format("WAVE! (%.0f)", dist); WaveLabel.TextColor3 = Color3.fromRGB(255,60,60)
    elseif dist < WAVE_SAFE_DISTANCE*2 then WaveLabel.Text = string.format("Wave near (%.0f)", dist); WaveLabel.TextColor3 = Color3.fromRGB(255,200,60)
    else WaveLabel.Text = "Waves: Safe"; WaveLabel.TextColor3 = Color3.fromRGB(100,255,100) end
end

local function updateTrialTimerDisplay()
    local active, timerText = isTrialTimerActive()
    if active then TrialDebugLabel.Text = "Timer: " .. timerText
    else
        local onCd, cdText = isTrialOnCooldown()
        if onCd then TrialDebugLabel.Text = "CD: " .. cdText
        else TrialDebugLabel.Text = "Timer: Ready" end
    end
end

local switchTab

--// ===================== TAB BAR ===================== --

local tabBarFrame = Instance.new("Frame"); tabBarFrame.Size = UDim2.new(1, -16, 0, isMobile and 22 or 30)
tabBarFrame.Position = UDim2.new(0, 8, 0, yOff)
tabBarFrame.BackgroundColor3 = Color3.fromRGB(18,18,28); tabBarFrame.BorderSizePixel = 0; tabBarFrame.Parent = contentFrame
Instance.new("UICorner", tabBarFrame).CornerRadius = UDim.new(0, 6); yOff = yOff + (isMobile and 25 or 33)

local brainrotTabBtn = Instance.new("TextButton"); brainrotTabBtn.Size = UDim2.new(0.5, -3, 1, -4)
brainrotTabBtn.Position = UDim2.new(0, 2, 0, 2); brainrotTabBtn.BackgroundColor3 = Color3.fromRGB(100,60,200)
brainrotTabBtn.BorderSizePixel = 0; brainrotTabBtn.Text = "Brainrot"; brainrotTabBtn.TextColor3 = Color3.new(1,1,1)
brainrotTabBtn.TextSize = isMobile and 9 or 13; brainrotTabBtn.Font = Enum.Font.GothamBold; brainrotTabBtn.Parent = tabBarFrame
Instance.new("UICorner", brainrotTabBtn).CornerRadius = UDim.new(0, 6)

local luckyBlockTabBtn = Instance.new("TextButton"); luckyBlockTabBtn.Size = UDim2.new(0.5, -3, 1, -4)
luckyBlockTabBtn.Position = UDim2.new(0.5, 1, 0, 2); luckyBlockTabBtn.BackgroundColor3 = Color3.fromRGB(40,40,60)
luckyBlockTabBtn.BorderSizePixel = 0; luckyBlockTabBtn.Text = "Lucky Blocks"; luckyBlockTabBtn.TextColor3 = Color3.fromRGB(150,150,150)
luckyBlockTabBtn.TextSize = isMobile and 9 or 13; luckyBlockTabBtn.Font = Enum.Font.GothamBold; luckyBlockTabBtn.Parent = tabBarFrame
Instance.new("UICorner", luckyBlockTabBtn).CornerRadius = UDim.new(0, 6)

--// ===================== SCROLL FRAMES ===================== --

local scrollH = isMobile and 60 or 120
local BrainrotScrollFrame = Instance.new("ScrollingFrame"); BrainrotScrollFrame.Size = UDim2.new(1, -16, 0, scrollH)
BrainrotScrollFrame.Position = UDim2.new(0, 8, 0, yOff); BrainrotScrollFrame.BackgroundColor3 = Color3.fromRGB(18,18,28)
BrainrotScrollFrame.BorderSizePixel = 0; BrainrotScrollFrame.ScrollBarThickness = isMobile and 4 or 6
BrainrotScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100,60,200); BrainrotScrollFrame.CanvasSize = UDim2.new(0,0,0,0)
BrainrotScrollFrame.ElasticBehavior = Enum.ElasticBehavior.Always; BrainrotScrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
BrainrotScrollFrame.Visible = true; BrainrotScrollFrame.Parent = contentFrame
Instance.new("UICorner", BrainrotScrollFrame).CornerRadius = UDim.new(0, 6)
local bll = Instance.new("UIListLayout", BrainrotScrollFrame); bll.Padding = UDim.new(0, isMobile and 2 or 3); bll.SortOrder = Enum.SortOrder.LayoutOrder
local bp = Instance.new("UIPadding", BrainrotScrollFrame); bp.PaddingTop = UDim.new(0,3); bp.PaddingLeft = UDim.new(0,3); bp.PaddingRight = UDim.new(0,3)

local LuckyBlockScrollFrame = Instance.new("ScrollingFrame"); LuckyBlockScrollFrame.Size = UDim2.new(1, -16, 0, scrollH)
LuckyBlockScrollFrame.Position = UDim2.new(0, 8, 0, yOff); LuckyBlockScrollFrame.BackgroundColor3 = Color3.fromRGB(18,18,28)
LuckyBlockScrollFrame.BorderSizePixel = 0; LuckyBlockScrollFrame.ScrollBarThickness = isMobile and 4 or 6
LuckyBlockScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(200,160,0); LuckyBlockScrollFrame.CanvasSize = UDim2.new(0,0,0,0)
LuckyBlockScrollFrame.ElasticBehavior = Enum.ElasticBehavior.Always; LuckyBlockScrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
LuckyBlockScrollFrame.Visible = false; LuckyBlockScrollFrame.Parent = contentFrame
Instance.new("UICorner", LuckyBlockScrollFrame).CornerRadius = UDim.new(0, 6)
local lll = Instance.new("UIListLayout", LuckyBlockScrollFrame); lll.Padding = UDim.new(0, isMobile and 2 or 3); lll.SortOrder = Enum.SortOrder.LayoutOrder
local lp = Instance.new("UIPadding", LuckyBlockScrollFrame); lp.PaddingTop = UDim.new(0,3); lp.PaddingLeft = UDim.new(0,3); lp.PaddingRight = UDim.new(0,3)
yOff = yOff + scrollH + 4

switchTab = function(tab)
    activeTab = tab
    if tab == "Brainrot" then
        brainrotTabBtn.BackgroundColor3 = Color3.fromRGB(100,60,200); brainrotTabBtn.TextColor3 = Color3.new(1,1,1)
        luckyBlockTabBtn.BackgroundColor3 = Color3.fromRGB(40,40,60); luckyBlockTabBtn.TextColor3 = Color3.fromRGB(150,150,150)
        BrainrotScrollFrame.Visible = true; LuckyBlockScrollFrame.Visible = false
        Title.Text = "Brainrot TP"; uiStroke.Color = Color3.fromRGB(100,60,200)
    else
        brainrotTabBtn.BackgroundColor3 = Color3.fromRGB(40,40,60); brainrotTabBtn.TextColor3 = Color3.fromRGB(150,150,150)
        luckyBlockTabBtn.BackgroundColor3 = Color3.fromRGB(200,160,0); luckyBlockTabBtn.TextColor3 = Color3.new(1,1,1)
        BrainrotScrollFrame.Visible = false; LuckyBlockScrollFrame.Visible = true
        Title.Text = "Lucky Block TP"; uiStroke.Color = Color3.fromRGB(200,160,0)
    end
end
brainrotTabBtn.MouseButton1Click:Connect(function() switchTab("Brainrot") end)
luckyBlockTabBtn.MouseButton1Click:Connect(function() switchTab("LuckyBlocks") end)

--// ===================== RARITY COLORS ===================== --

local RARITY_ORDER_C = {{"uncommon",Color3.fromRGB(80,200,80)},{"common",Color3.fromRGB(180,180,180)},{"rare",Color3.fromRGB(60,120,255)},
    {"epic",Color3.fromRGB(180,60,255)},{"legendary",Color3.fromRGB(255,180,0)},{"mythic",Color3.fromRGB(255,50,50)},
    {"secret",Color3.fromRGB(255,0,100)},{"divine",Color3.fromRGB(255,220,100)}}
local function getRarityColor(n) local l = string.lower(n); for _, p in ipairs(RARITY_ORDER_C) do if string.find(l, p[1]) then return p[2] end end; return Color3.fromRGB(200,200,200) end

--// ===================== CHECKBOXES ===================== --

local function createBrainrotCheckbox(rn, idx)
    local btn = Instance.new("TextButton"); btn.Size = UDim2.new(1, -6, 0, checkHeight); btn.BackgroundColor3 = Color3.fromRGB(35,35,50)
    btn.BorderSizePixel = 0; btn.Text = ""; btn.LayoutOrder = idx; btn.Parent = BrainrotScrollFrame
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
    local ckSize = checkHeight - (isMobile and 6 or 8)
    local ck = Instance.new("TextLabel"); ck.Size = UDim2.new(0, ckSize, 0, ckSize)
    ck.Position = UDim2.new(0, 4, 0.5, -ckSize/2); ck.BackgroundColor3 = Color3.fromRGB(50,50,70)
    ck.BorderSizePixel = 0; ck.Text = ""; ck.TextSize = isMobile and 10 or 14; ck.TextColor3 = Color3.fromRGB(100,255,100)
    ck.Font = Enum.Font.GothamBold; ck.Parent = btn; Instance.new("UICorner", ck).CornerRadius = UDim.new(0, 4)
    local lb = Instance.new("TextLabel"); lb.Size = UDim2.new(1, -60, 1, 0); lb.Position = UDim2.new(0, checkHeight, 0, 0)
    lb.BackgroundTransparency = 1; lb.Text = rn; lb.TextColor3 = getRarityColor(rn); lb.TextSize = isMobile and 9 or 13
    lb.Font = Enum.Font.GothamSemibold; lb.TextXAlignment = Enum.TextXAlignment.Left; lb.Parent = btn
    local cl = Instance.new("TextLabel"); cl.Size = UDim2.new(0, 26, 1, 0); cl.Position = UDim2.new(1, -28, 0, 0)
    cl.BackgroundTransparency = 1; cl.TextColor3 = Color3.fromRGB(140,140,140); cl.TextSize = isMobile and 8 or 11
    cl.Font = Enum.Font.Gotham; cl.Parent = btn
    local f = BRAINROT_PATH:FindFirstChild(rn); cl.Text = f and tostring(#f:GetChildren()) or "0"
    btn.MouseButton1Click:Connect(function()
        if brainrotSelectedRarities[rn] then brainrotSelectedRarities[rn] = nil; ck.Text = ""; ck.BackgroundColor3 = Color3.fromRGB(50,50,70)
        else brainrotSelectedRarities[rn] = true; ck.Text = "Y"; ck.BackgroundColor3 = Color3.fromRGB(40,100,40) end
    end)
    brainrotCheckboxes[rn] = {Button=btn, Check=ck, CountLabel=cl, Label=lb}
end

local function createLuckyBlockCheckbox(rn, idx)
    local btn = Instance.new("TextButton"); btn.Size = UDim2.new(1, -6, 0, checkHeight); btn.BackgroundColor3 = Color3.fromRGB(35,35,50)
    btn.BorderSizePixel = 0; btn.Text = ""; btn.LayoutOrder = idx; btn.Parent = LuckyBlockScrollFrame
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
    local ckSize = checkHeight - (isMobile and 6 or 8)
    local ck = Instance.new("TextLabel"); ck.Size = UDim2.new(0, ckSize, 0, ckSize)
    ck.Position = UDim2.new(0, 4, 0.5, -ckSize/2); ck.BackgroundColor3 = Color3.fromRGB(50,50,70)
    ck.BorderSizePixel = 0; ck.Text = ""; ck.TextSize = isMobile and 10 or 14; ck.TextColor3 = Color3.fromRGB(255,220,80)
    ck.Font = Enum.Font.GothamBold; ck.Parent = btn; Instance.new("UICorner", ck).CornerRadius = UDim.new(0, 4)
    local lb = Instance.new("TextLabel"); lb.Size = UDim2.new(1, -60, 1, 0); lb.Position = UDim2.new(0, checkHeight, 0, 0)
    lb.BackgroundTransparency = 1; lb.Text = rn; lb.TextColor3 = getRarityColor(rn); lb.TextSize = isMobile and 9 or 13
    lb.Font = Enum.Font.GothamSemibold; lb.TextXAlignment = Enum.TextXAlignment.Left; lb.Parent = btn
    local cl = Instance.new("TextLabel"); cl.Size = UDim2.new(0, 26, 1, 0); cl.Position = UDim2.new(1, -28, 0, 0)
    cl.BackgroundTransparency = 1; cl.TextColor3 = Color3.fromRGB(140,140,140); cl.TextSize = isMobile and 8 or 11
    cl.Font = Enum.Font.Gotham; cl.Parent = btn; cl.Text = tostring(getLuckyBlockRarityCount(rn))
    btn.MouseButton1Click:Connect(function()
        if luckyBlockSelectedRarities[rn] then luckyBlockSelectedRarities[rn] = nil; ck.Text = ""; ck.BackgroundColor3 = Color3.fromRGB(50,50,70)
        else luckyBlockSelectedRarities[rn] = true; ck.Text = "Y"; ck.BackgroundColor3 = Color3.fromRGB(100,80,0) end
    end)
    luckyBlockCheckboxes[rn] = {Button=btn, Check=ck, CountLabel=cl}
end

--// ===================== SLIDERS ===================== --

local function createSlider(lt, mi, ma, def, cb)
    local sl = Instance.new("TextLabel"); sl.Size = UDim2.new(1, -16, 0, isMobile and 10 or 14); sl.Position = UDim2.new(0, 8, 0, yOff)
    sl.BackgroundTransparency = 1; sl.Text = lt..": "..def; sl.TextColor3 = Color3.fromRGB(180,180,180)
    sl.TextSize = fontSize-1; sl.Font = Enum.Font.Gotham; sl.TextXAlignment = Enum.TextXAlignment.Left; sl.Parent = contentFrame; yOff += (isMobile and 11 or 15)
    local bg = Instance.new("Frame"); bg.Size = UDim2.new(1, -16, 0, sliderH); bg.Position = UDim2.new(0, 8, 0, yOff)
    bg.BackgroundColor3 = Color3.fromRGB(40,40,55); bg.BorderSizePixel = 0; bg.Parent = contentFrame
    Instance.new("UICorner", bg).CornerRadius = UDim.new(1, 0); yOff += sliderH + (isMobile and 3 or 4)
    local fl = Instance.new("Frame"); fl.Size = UDim2.new((def-mi)/(ma-mi), 0, 1, 0)
    fl.BackgroundColor3 = Color3.fromRGB(100,60,200); fl.BorderSizePixel = 0; fl.Parent = bg
    Instance.new("UICorner", fl).CornerRadius = UDim.new(1, 0)
    local thS = sliderH + (isMobile and 4 or 6)
    local th = Instance.new("Frame"); th.Size = UDim2.new(0, thS, 0, thS)
    th.Position = UDim2.new((def-mi)/(ma-mi), -thS/2, 0.5, -thS/2)
    th.BackgroundColor3 = Color3.fromRGB(200,150,255); th.BorderSizePixel = 0; th.ZIndex = 2; th.Parent = bg
    Instance.new("UICorner", th).CornerRadius = UDim.new(1, 0)
    local sd = false
    local function us(i) local r = math.clamp((i.Position.X-bg.AbsolutePosition.X)/bg.AbsoluteSize.X, 0, 1); local v = math.floor(r*(ma-mi)+mi)
        fl.Size = UDim2.new(r, 0, 1, 0); th.Position = UDim2.new(r, -thS/2, 0.5, -thS/2); sl.Text = lt..": "..v; cb(v) end
    bg.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then sd=true; us(i) end end)
    th.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then sd=true end end)
    UserInputService.InputChanged:Connect(function(i) if sd and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then us(i) end end)
    UserInputService.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then sd=false end end)
end

--// MOBILE LIMIT: Use capped ranges for Speed and Depth sliders on mobile
local speedSliderMax = isMobile and 100 or 4000
local depthSliderMin = isMobile and -5 or -200
local depthSliderMax = isMobile and -1 or -10

createSlider("Speed", 10, speedSliderMax, math.clamp(TWEEN_SPEED, 10, speedSliderMax), function(v) TWEEN_SPEED = v end)
createSlider("Depth", depthSliderMin, depthSliderMax, math.clamp(TRAVEL_DEPTH, depthSliderMin, depthSliderMax), function(v) TRAVEL_DEPTH = v end)
createSlider("Grab H", 0, 20, GRAB_HEIGHT, function(v) GRAB_HEIGHT = v end)
createSlider("Wave Safe", 30, 300, WAVE_SAFE_DISTANCE, function(v) WAVE_SAFE_DISTANCE = v end)

--// ===================== TOGGLES ===================== --

local function createToggle(lt, def, col, cb)
    local tBG = Instance.new("Frame"); tBG.Size = UDim2.new(1, -16, 0, toggleH); tBG.Position = UDim2.new(0, 8, 0, yOff)
    tBG.BackgroundColor3 = Color3.fromRGB(35,35,50); tBG.BorderSizePixel = 0; tBG.Parent = contentFrame
    Instance.new("UICorner", tBG).CornerRadius = UDim.new(0, 6); yOff += toggleH + (isMobile and 2 or 3)
    local tL = Instance.new("TextLabel"); tL.Size = UDim2.new(1, -50, 1, 0); tL.Position = UDim2.new(0, 6, 0, 0)
    tL.BackgroundTransparency = 1; tL.Text = lt; tL.TextColor3 = col; tL.TextSize = isMobile and 8 or 12
    tL.Font = Enum.Font.GothamSemibold; tL.TextXAlignment = Enum.TextXAlignment.Left; tL.TextWrapped = true; tL.Parent = tBG
    local tBtnW = isMobile and 36 or 48
    local tBtnH = toggleH - (isMobile and 6 or 10)
    local tB = Instance.new("TextButton"); tB.Size = UDim2.new(0, tBtnW, 0, tBtnH)
    tB.Position = UDim2.new(1, -(tBtnW+4), 0.5, -tBtnH/2)
    tB.BackgroundColor3 = def and Color3.fromRGB(40,160,40) or Color3.fromRGB(60,60,80)
    tB.BorderSizePixel = 0; tB.Text = def and "ON" or "OFF"; tB.TextColor3 = Color3.fromRGB(220,220,220)
    tB.TextSize = isMobile and 8 or 12; tB.Font = Enum.Font.GothamBold; tB.Parent = tBG
    Instance.new("UICorner", tB).CornerRadius = UDim.new(1, 0)
    local st = def
    tB.MouseButton1Click:Connect(function() st = not st; tB.Text = st and "ON" or "OFF"
        tB.BackgroundColor3 = st and Color3.fromRGB(40,160,40) or Color3.fromRGB(60,60,80); cb(st) end)
    return tB
end

createToggle("Instant Prompts", false, Color3.fromRGB(255,220,80), function(v) if v then enableAutoInstantPrompts() else disableAutoInstantPrompts() end end)
local autoReturnEnabled = true
createToggle("Auto Return", true, Color3.fromRGB(100,255,180), function(v) autoReturnEnabled = v end)
local waveCheckEnabled = true
createToggle("Wave Safety", true, Color3.fromRGB(255,100,100), function(v) waveCheckEnabled = v end)

--// ===================== PICK UP 1 BRAINROT ===================== --

local function pickupOneBrainrot(target)
    if not target.Part or not target.Part.Parent or not target.Object or not target.Object.Parent then return false end
    refreshChar()
    local targetPos = target.Part.CFrame.Position
    TrialCollectLabel.Text = "Diving to " .. target.Name .. "..."
    TrialCollectLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
    smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y + TRAVEL_DEPTH, rootPart.Position.Z), DIVE_SPEED)
    task.wait(0.05)
    if not autoTrialEnabled then return false end
    smoothTween(CFrame.new(targetPos.X, targetPos.Y + TRAVEL_DEPTH, targetPos.Z), TWEEN_SPEED)
    task.wait(0.05)
    if not autoTrialEnabled then return false end
    if not target.Part or not target.Part.Parent then return false end
    local freshPos = target.Part.CFrame.Position
    if waveCheckEnabled and isWaveApproaching(freshPos, WAVE_SAFE_DISTANCE) then
        TrialCollectLabel.Text = "Wave! Waiting..."
        TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 60, 60)
        waitForWavesToClear(freshPos, function() end)
        if not autoTrialEnabled or not target.Part or not target.Part.Parent then return false end
        task.wait(0.2)
    end
    if not target.Part or not target.Part.Parent then return false end
    local fp2 = target.Part.CFrame.Position
    TrialCollectLabel.Text = "Rising to grab..."
    TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
    smoothTween(CFrame.new(fp2.X, fp2.Y + GRAB_HEIGHT, fp2.Z), RISE_SPEED)
    if waveCheckEnabled and isWaveNearby(rootPart.Position, WAVE_SAFE_DISTANCE * 0.5) then
        TrialCollectLabel.Text = "Emergency dive!"
        TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y + TRAVEL_DEPTH, rootPart.Position.Z), DIVE_SPEED * 2)
        task.wait(0.5)
        return false
    end
    if target.Part and target.Part.Parent then
        if bodyVel and bodyVel.Parent then bodyVel.MaxForce = Vector3.zero end
        rootPart.CFrame = target.Part.CFrame * CFrame.new(0, 2, 0)
        rootPart.Velocity = Vector3.zero; rootPart.AssemblyLinearVelocity = Vector3.zero
        task.wait(0.05)
        if bodyVel and bodyVel.Parent then bodyVel.MaxForce = Vector3.new(1e9,1e9,1e9); bodyVel.Velocity = Vector3.zero end
    end
    TrialCollectLabel.Text = "GRAB: " .. target.Name
    TrialCollectLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
    grabAllPrompts(target.Object)
    grabNearbyPrompts(targetPos, 15)
    pcall(function()
        for _, p in pairs(target.Object:GetDescendants()) do
            if p:IsA("BasePart") then firetouchinterest(rootPart, p, 0); task.wait(); firetouchinterest(rootPart, p, 1) end
        end
        if target.Part and target.Part.Parent then
            firetouchinterest(rootPart, target.Part, 0); task.wait(); firetouchinterest(rootPart, target.Part, 1)
        end
    end)
    pcall(function()
        for _, d in pairs(target.Object:GetDescendants()) do
            if d:IsA("ClickDetector") then fireclickdetector(d) end
        end
    end)
    task.wait(WAIT_AT_TARGET)
    return true
end

--// ===================== AUTO TRIAL LOOP ===================== --

local function stopAutoTrial()
    autoTrialEnabled = false; autoTrialRunning = false; trialInProgress = false; trialCollecting = false
    stopTween()
    stopContinuousTracker()
    resetRarityTracker()
    restorePreviousSelections()
    if savedTrialTab then switchTab(savedTrialTab); savedTrialTab = nil end
    if rootPart and rootPart.Parent then
        rootPart.Velocity = Vector3.zero
        rootPart.AssemblyLinearVelocity = Vector3.zero
        rootPart.AssemblyAngularVelocity = Vector3.zero
    end
    if not running then
        unlockPhysics()
        disableNoclip()
    end
    TrialStatusLabel.Text = "Trial: OFF"; TrialStatusLabel.TextColor3 = Color3.fromRGB(180,180,180)
    TrialDetailLabel.Text = "Requirement: --"
    TrialCollectLabel.Text = "Collecting: --"; TrialCollectLabel.TextColor3 = Color3.fromRGB(255,255,0)
    TrialTrackerLabel.Text = "Tracker: Idle"; TrialTrackerLabel.TextColor3 = Color3.fromRGB(255,150,255)
    TrialProgressLabel.Text = "Progress: 0/0"
    TrialDebugLabel.Text = "Debug: --"
end

local function doOneTrialRun()
    trialInProgress = true; trialGrabbed = 0; trialCollecting = false
    resetRarityTracker()
    TrialStatusLabel.Text = "Trial: Starting..."
    TrialStatusLabel.TextColor3 = Color3.fromRGB(255,200,0)
    TrialCollectLabel.Text = "Preparing..."
    TrialTrackerLabel.Text = "Tracker: Init..."
    enableNoclip(); lockPhysics()
    saveCurrentSelections()
    switchTab("Brainrot")
    TrialDetailLabel.Text = "Going to tower..."
    travelToTower()
    task.wait(0.3)
    updateTrialTimerDisplay()
    local onCd, cdText = isTrialOnCooldown()
    if onCd then
        TrialStatusLabel.Text = "Trial: Cooldown"
        TrialDetailLabel.Text = "CD: " .. cdText
        TrialCollectLabel.Text = "Waiting for CD..."
        restorePreviousSelections()
        trialInProgress = false
        return false, "cooldown"
    end
    local timerActive = isTrialTimerActive()
    if not timerActive then
        TrialDetailLabel.Text = "Starting trial..."
        fireTrialPrompt()
        task.wait(1.5)
        updateTrialTimerDisplay()
    end
    TrialDetailLabel.Text = "Scanning..."
    task.wait(0.5)
    local detectedRarity, detectedCount, sourceText, debugInfo = scanWithRetry(6, 0.4)
    if not detectedRarity then
        TrialStatusLabel.Text = "Trial: Can't detect!"
        TrialDetailLabel.Text = "No rarity found"
        TrialCollectLabel.Text = "FAILED"
        TrialCollectLabel.TextColor3 = Color3.fromRGB(255,60,60)
        TrialDebugLabel.Text = debugInfo or "no debug"
        restorePreviousSelections()
        trialInProgress = false
        return false, "no_rarity"
    end
    local folderName = matchRarityToFolder(detectedRarity)
    if not folderName then
        TrialStatusLabel.Text = "Trial: No folder '" .. detectedRarity .. "'"
        TrialCollectLabel.Text = "No folder"
        TrialCollectLabel.TextColor3 = Color3.fromRGB(255,120,0)
        TrialDebugLabel.Text = debugInfo or "no debug"
        restorePreviousSelections()
        trialInProgress = false
        return false, "no_folder"
    end
    currentTrialRarity = detectedRarity
    currentTrialFolder = folderName
    trialRequired = detectedCount or 1
    trialCollecting = true
    autoSelectTrialRarity(folderName)
    TrialStatusLabel.Text = string.format("Need %d %s", trialRequired, folderName)
    TrialStatusLabel.TextColor3 = Color3.fromRGB(0,255,100)
    TrialDetailLabel.Text = string.format("★%s (%s)", folderName, detectedRarity)
    TrialCollectLabel.Text = string.format("Batch: %d", TRIAL_BATCH_SIZE)
    TrialCollectLabel.TextColor3 = Color3.fromRGB(0,255,100)
    TrialProgressLabel.Text = string.format("Got:0 Need:%d %s", trialRequired, folderName)
    updateTrackerLabel()
    startContinuousTracker()
    local trialStart = tick()
    while autoTrialEnabled and (tick() - trialStart) < TRIAL_TIME_LIMIT do
        refreshChar()
        local remaining = math.ceil(TRIAL_TIME_LIMIT - (tick() - trialStart))
        TrialStatusLabel.Text = string.format("★%s★ [%ds]", currentTrialFolder, remaining)
        TrialStatusLabel.TextColor3 = Color3.fromRGB(0,200,255)
        updateTrialTimerDisplay()
        updateTrackerLabel()
        local initialTargets = getBrainrots({currentTrialFolder})
        if #initialTargets == 0 then
            TrialCollectLabel.Text = "No " .. currentTrialFolder .. " waiting..."
            TrialCollectLabel.TextColor3 = Color3.fromRGB(255,200,0)
            task.wait(1.5)
            local timerOk = isTrialTimerActive()
            if not timerOk then
                local checkR = scanTrialFromBillboard()
                if not checkR then
                    TrialStatusLabel.Text = "COMPLETED!"
                    TrialStatusLabel.TextColor3 = Color3.fromRGB(0,255,0)
                    TrialCollectLabel.Text = "ALL DONE!"
                    TrialCollectLabel.TextColor3 = Color3.fromRGB(0,255,0)
                    stopContinuousTracker()
                    restorePreviousSelections(); trialInProgress = false; trialCollecting = false
                    return true, "completed"
                end
            end
            continue
        end
        local batchCollected = 0
        local maxAttempts = TRIAL_BATCH_SIZE + 2
        local attempts = 0
        while batchCollected < TRIAL_BATCH_SIZE and attempts < maxAttempts do
            attempts += 1
            if not autoTrialEnabled then break end
            if (tick() - trialStart) >= TRIAL_TIME_LIMIT then break end
            refreshChar()
            local batchTargets = getBrainrots({currentTrialFolder})
            if #batchTargets == 0 then
                if batchCollected > 0 then
                    TrialCollectLabel.Text = string.format("No more (got %d/%d)", batchCollected, TRIAL_BATCH_SIZE)
                    TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
                end
                break
            end
            local target = nil
            for _, t in ipairs(batchTargets) do
                if t.Part and t.Part.Parent and t.Object and t.Object.Parent then target = t; break end
            end
            if not target then
                if batchCollected > 0 then TrialCollectLabel.Text = string.format("No valid (%d/%d)", batchCollected, TRIAL_BATCH_SIZE) end
                break
            end
            TrialCollectLabel.Text = string.format("Pick %d/%d: %s", batchCollected + 1, TRIAL_BATCH_SIZE, target.Name)
            TrialCollectLabel.TextColor3 = Color3.fromRGB(0, 200, 255)
            local pickSuccess = pickupOneBrainrot(target)
            if not autoTrialEnabled then break end
            if pickSuccess then
                batchCollected += 1; trialGrabbed += 1; totalGrabbed += 1
                GrabLabel.Text = "Grabbed: " .. totalGrabbed
                TrialCollectLabel.Text = string.format("✓%d/%d: %s", batchCollected, TRIAL_BATCH_SIZE, target.Name)
                TrialCollectLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                TrialProgressLabel.Text = string.format("Got:%d Batch:%d/%d", trialGrabbed, batchCollected, TRIAL_BATCH_SIZE)
            else
                TrialCollectLabel.Text = string.format("✗Miss (%d/%d)", batchCollected, TRIAL_BATCH_SIZE)
                TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 150, 0)
            end
            task.wait(0.1)
        end
        if batchCollected > 0 then
            TrialCollectLabel.Text = string.format("Deliver %d...", batchCollected)
            TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
            TrialProgressLabel.Text = string.format("Got:%d Deliver %d...", trialGrabbed, batchCollected)
            travelToTower()
            task.wait(0.2)
            TrialCollectLabel.Text = string.format("Delivering %d...", batchCollected)
            for deliverNum = 1, batchCollected + 1 do
                fireTrialPrompt(); task.wait(0.3)
                if not autoTrialEnabled then break end
            end
            if not autoTrialEnabled then break end
            TrialCollectLabel.Text = "Re-scanning..."
            TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
            local newR, newC, scanStatus, scanDebug = trackerRescanAtTower()
            if scanStatus == "completed" then
                TrialStatusLabel.Text = "COMPLETED!"
                TrialStatusLabel.TextColor3 = Color3.fromRGB(0,255,0)
                TrialCollectLabel.Text = string.format("DONE! %d got, %d swaps", trialGrabbed, rarityChangeCount)
                TrialCollectLabel.TextColor3 = Color3.fromRGB(0,255,0)
                TrialTrackerLabel.Text = string.format("COMPLETE! (%d swaps)", rarityChangeCount)
                TrialTrackerLabel.TextColor3 = Color3.fromRGB(0,255,0)
                TrialProgressLabel.Text = string.format("DONE: %d total", trialGrabbed)
                stopContinuousTracker()
                restorePreviousSelections(); trialInProgress = false; trialCollecting = false
                return true, "completed"
            elseif scanStatus == "changed" then
                TrialCollectLabel.Text = string.format("⚡%s→%s⚡", previousTrialRarity or "?", currentTrialFolder)
                TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 50, 255)
                TrialDetailLabel.Text = string.format("★Need:%d %s (#%d)", newC or 1, currentTrialFolder, rarityChangeCount)
                TrialDetailLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
                TrialProgressLabel.Text = string.format("Got:%d Now:%s", trialGrabbed, currentTrialFolder)
                TrialDebugLabel.Text = string.format("Swap#%d: %s→%s", rarityChangeCount, previousTrialRarity or "?", currentTrialRarity)
                updateTrackerLabel()
                task.wait(0.3)
            elseif scanStatus == "same" then
                trialRequired = newC or 1
                TrialCollectLabel.Text = string.format("Need %s (%d left)", currentTrialFolder, trialRequired)
                TrialCollectLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                TrialDetailLabel.Text = string.format("★Continue: %d %s", trialRequired, currentTrialFolder)
                TrialProgressLabel.Text = string.format("Got:%d Need:%d %s", trialGrabbed, trialRequired, currentTrialFolder)
                updateTrackerLabel()
            elseif scanStatus == "no_folder" then
                TrialCollectLabel.Text = "No folder: " .. (newR or "?")
                TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 120, 0)
                TrialDebugLabel.Text = "Missing: " .. (newR or "?")
            end
        else
            TrialCollectLabel.Text = "Failed grab, retry..."
            TrialCollectLabel.TextColor3 = Color3.fromRGB(255, 100, 0)
            task.wait(0.5)
        end
        if not autoTrialEnabled then break end
        task.wait(0.2)
    end
    stopContinuousTracker()
    TrialStatusLabel.Text = "Trial: Time up"
    TrialStatusLabel.TextColor3 = Color3.fromRGB(200,200,200)
    TrialCollectLabel.Text = string.format("End: %d got, %d swaps", trialGrabbed, rarityChangeCount)
    TrialCollectLabel.TextColor3 = Color3.fromRGB(200,200,200)
    TrialTrackerLabel.Text = string.format("Done (%d swaps)", rarityChangeCount)
    restorePreviousSelections()
    trialInProgress = false; trialCollecting = false
    return true, "timeout"
end

local function startAutoTrialLoop()
    if autoTrialRunning then return end
    autoTrialEnabled = true; autoTrialRunning = true
    TrialStatusLabel.Text = "Trial: ACTIVE"
    TrialStatusLabel.TextColor3 = Color3.fromRGB(0,200,255)
    TrialCollectLabel.Text = "Starting..."
    TrialCollectLabel.TextColor3 = Color3.fromRGB(255,255,0)
    TrialTrackerLabel.Text = "Tracker: Starting..."
    if not savedCFrame then saveCurrentPosition(); updateSavedPosLabel() end
    task.spawn(function()
        enableNoclip(); lockPhysics()
        while autoTrialEnabled do
            local wasFarming = running
            if wasFarming then running = false; stopTween(); task.wait(0.5) end
            local success, reason = doOneTrialRun()
            stopContinuousTracker()
            if savedCFrame and autoTrialEnabled then
                TrialCollectLabel.Text = "Returning..."
                returnToSaved(true); task.wait(0.3)
            end
            if savedTrialTab and autoTrialEnabled then switchTab(savedTrialTab) end
            if wasFarming and autoTrialEnabled then running = true end
            if not autoTrialEnabled then break end
            local waitTime = reason == "cooldown" and 30 or TRIAL_COOLDOWN_WAIT
            for i = waitTime, 1, -1 do
                if not autoTrialEnabled then break end
                TrialStatusLabel.Text = string.format("Next in %ds", i)
                TrialStatusLabel.TextColor3 = Color3.fromRGB(100,180,255)
                TrialCollectLabel.Text = "Waiting..."
                TrialCollectLabel.TextColor3 = Color3.fromRGB(150,150,150)
                TrialTrackerLabel.Text = "Idle (cooldown)"
                updateTrialTimerDisplay()
                task.wait(1)
            end
        end
        autoTrialRunning = false
        stopContinuousTracker()
        if not running then unlockPhysics(); disableNoclip() end
        TrialStatusLabel.Text = "Trial: OFF"
        TrialCollectLabel.Text = "Collecting: --"
        TrialTrackerLabel.Text = "Tracker: Idle"
    end)
end

createToggle("Auto Trial Tsunami", false, Color3.fromRGB(0,180,255), function(v)
    if v then startAutoTrialLoop() else stopAutoTrial() end
end)

--// ===================== BUTTONS ===================== --

local function createButton(t, c)
    local b = Instance.new("TextButton"); b.Size = UDim2.new(0.48, -2, 0, btnHeight); b.BackgroundColor3 = c
    b.BorderSizePixel = 0; b.Text = t; b.TextColor3 = Color3.new(1,1,1); b.TextSize = isMobile and 9 or 13
    b.Font = Enum.Font.GothamBold; Instance.new("UICorner", b).CornerRadius = UDim.new(0, 8); return b
end

local row1 = Instance.new("Frame"); row1.Size = UDim2.new(1, -16, 0, btnHeight); row1.Position = UDim2.new(0, 8, 0, yOff)
row1.BackgroundTransparency = 1; row1.Parent = contentFrame; yOff += btnHeight + (isMobile and 2 or 3)
local StartBtn = createButton("START", Color3.fromRGB(40,140,40)); StartBtn.Size = UDim2.new(0.48,0,1,0); StartBtn.Position = UDim2.new(0,0,0,0); StartBtn.Parent = row1
local StopBtn = createButton("STOP", Color3.fromRGB(180,40,40)); StopBtn.Size = UDim2.new(0.48,0,1,0); StopBtn.Position = UDim2.new(0.52,0,0,0); StopBtn.Parent = row1

local row2 = Instance.new("Frame"); row2.Size = UDim2.new(1, -16, 0, btnHeight); row2.Position = UDim2.new(0, 8, 0, yOff)
row2.BackgroundTransparency = 1; row2.Parent = contentFrame; yOff += btnHeight + (isMobile and 2 or 3)
local RefreshBtn = createButton("REFRESH", Color3.fromRGB(40,80,160)); RefreshBtn.Size = UDim2.new(0.48,0,1,0); RefreshBtn.Position = UDim2.new(0,0,0,0); RefreshBtn.Parent = row2
local SelectAllBtn = createButton("ALL", Color3.fromRGB(100,60,160)); SelectAllBtn.Size = UDim2.new(0.48,0,1,0); SelectAllBtn.Position = UDim2.new(0.52,0,0,0); SelectAllBtn.Parent = row2

local row3 = Instance.new("Frame"); row3.Size = UDim2.new(1, -16, 0, btnHeight); row3.Position = UDim2.new(0, 8, 0, yOff)
row3.BackgroundTransparency = 1; row3.Parent = contentFrame; yOff += btnHeight + (isMobile and 2 or 3)
local SavePosBtn = createButton("SAVE POS", Color3.fromRGB(180,120,0)); SavePosBtn.Size = UDim2.new(0.48,0,1,0); SavePosBtn.Position = UDim2.new(0,0,0,0); SavePosBtn.Parent = row3
local ReturnBtn = createButton("RETURN", Color3.fromRGB(0,140,180)); ReturnBtn.Size = UDim2.new(0.48,0,1,0); ReturnBtn.Position = UDim2.new(0.52,0,0,0); ReturnBtn.Parent = row3

local row4 = Instance.new("Frame"); row4.Size = UDim2.new(1, -16, 0, btnHeight); row4.Position = UDim2.new(0, 8, 0, yOff)
row4.BackgroundTransparency = 1; row4.Parent = contentFrame; yOff += btnHeight + (isMobile and 2 or 3)
local ScanTrialBtn = createButton("SCAN", Color3.fromRGB(0,150,200)); ScanTrialBtn.Size = UDim2.new(0.48,0,1,0); ScanTrialBtn.Position = UDim2.new(0,0,0,0); ScanTrialBtn.Parent = row4
local GoTowerBtn = createButton("TOWER", Color3.fromRGB(180,100,0)); GoTowerBtn.Size = UDim2.new(0.48,0,1,0); GoTowerBtn.Position = UDim2.new(0.52,0,0,0); GoTowerBtn.Parent = row4

ScanTrialBtn.MouseButton1Click:Connect(function()
    TrialDetailLabel.Text = "Scanning..."
    local r, c, t, debug = scanWithRetry(4, 0.3)
    if r then
        local folder = matchRarityToFolder(r)
        TrialDetailLabel.Text = string.format("Need:%d %s→%s", c or 1, r, folder or "NONE")
        TrialDetailLabel.TextColor3 = Color3.fromRGB(0,255,100)
        TrialDebugLabel.Text = string.format("Src: %s", t or "?")
    else
        TrialDetailLabel.Text = "No rarity found!"
        TrialDetailLabel.TextColor3 = Color3.fromRGB(255,80,80)
        TrialDebugLabel.Text = debug or "none"
    end
    updateTrialTimerDisplay()
end)

GoTowerBtn.MouseButton1Click:Connect(function()
    if running then return end
    GoTowerBtn.BackgroundColor3 = Color3.fromRGB(255,200,0)
    TrialDetailLabel.Text = "Going to tower..."
    task.spawn(function()
        enableNoclip(); lockPhysics()
        travelToTower(); task.wait(0.3)
        fireTrialPrompt()
        updateTrialTimerDisplay()
        TrialDetailLabel.Text = "At tower - scanning..."
        task.wait(0.5)
        local r, c, t = scanWithRetry(4, 0.3)
        if r then
            local folder = matchRarityToFolder(r)
            TrialDetailLabel.Text = string.format("Need:%d %s→%s", c or 1, r, folder or "NONE")
            TrialDetailLabel.TextColor3 = Color3.fromRGB(0,255,100)
        else
            TrialDetailLabel.Text = "No rarity at tower"
            TrialDetailLabel.TextColor3 = Color3.fromRGB(255,80,80)
        end
        GoTowerBtn.BackgroundColor3 = Color3.fromRGB(0,200,40)
        task.delay(1, function() GoTowerBtn.BackgroundColor3 = Color3.fromRGB(180,100,0) end)
    end)
end)

local LogFrame = Instance.new("Frame"); LogFrame.Size = UDim2.new(1, -16, 0, isMobile and 22 or 30)
LogFrame.Position = UDim2.new(0, 8, 0, yOff)
LogFrame.BackgroundColor3 = Color3.fromRGB(18,18,28); LogFrame.BorderSizePixel = 0; LogFrame.Parent = contentFrame
Instance.new("UICorner", LogFrame).CornerRadius = UDim.new(0, 6)
local LogLabel = Instance.new("TextLabel"); LogLabel.Size = UDim2.new(1, -8, 1, 0); LogLabel.Position = UDim2.new(0, 4, 0, 0)
LogLabel.BackgroundTransparency = 1; LogLabel.Text = "Last: --"; LogLabel.TextColor3 = Color3.fromRGB(130,130,160)
LogLabel.TextSize = isMobile and 7 or 10; LogLabel.Font = Enum.Font.Gotham; LogLabel.TextXAlignment = Enum.TextXAlignment.Left
LogLabel.TextWrapped = true; LogLabel.Parent = LogFrame; yOff += (isMobile and 26 or 34)

contentFrame.CanvasSize = UDim2.new(0, 0, 0, yOff + 10)

--// ===================== WAVE MONITOR ===================== --
RunService.Heartbeat:Connect(function() if rootPart and rootPart.Parent then updateWaveStatus(rootPart.Position) end end)

--// ===================== MAIN FARMING ===================== --

player.CharacterAdded:Connect(function(char)
    character = char; humanoid = char:WaitForChild("Humanoid"); rootPart = char:WaitForChild("HumanoidRootPart")
    if running or autoTrialRunning then task.wait(0.5); enableNoclip(); lockPhysics() end
end)

local function refreshBrainrotFolders()
    for _, d in pairs(brainrotCheckboxes) do d.Button:Destroy() end; brainrotCheckboxes = {}
    local f = scanRarityFolders(); for i, n in ipairs(f) do createBrainrotCheckbox(n, i) end
    local l = BrainrotScrollFrame:FindFirstChildOfClass("UIListLayout")
    if l then l:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        BrainrotScrollFrame.CanvasSize = UDim2.new(0,0,0,l.AbsoluteContentSize.Y+8) end)
        BrainrotScrollFrame.CanvasSize = UDim2.new(0,0,0,l.AbsoluteContentSize.Y+8) end; return #f
end
local function refreshLuckyBlockRarities()
    for _, d in pairs(luckyBlockCheckboxes) do d.Button:Destroy() end; luckyBlockCheckboxes = {}
    local r = scanLuckyBlockRarities(); for i, n in ipairs(r) do createLuckyBlockCheckbox(n, i) end
    local l = LuckyBlockScrollFrame:FindFirstChildOfClass("UIListLayout")
    if l then l:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        LuckyBlockScrollFrame.CanvasSize = UDim2.new(0,0,0,l.AbsoluteContentSize.Y+8) end)
        LuckyBlockScrollFrame.CanvasSize = UDim2.new(0,0,0,l.AbsoluteContentSize.Y+8) end; return #r
end
local function refreshActiveTab()
    if activeTab == "Brainrot" then StatusLabel.Text = "Found "..refreshBrainrotFolders().." folders"
    else StatusLabel.Text = "Found "..refreshLuckyBlockRarities().." rarities" end
end

local function startFarming()
    if running then return end; running = true; farmingTab = activeTab
    if not savedCFrame then saveCurrentPosition(); updateSavedPosLabel(); LogLabel.Text = "Auto-saved" end
    enableNoclip(); lockPhysics(); StatusLabel.Text = "Running..."; StartBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
    task.spawn(function()
    refreshChar(); smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y+TRAVEL_DEPTH, rootPart.Position.Z), DIVE_SPEED)
        if not running then
            if not autoTrialRunning then unlockPhysics(); disableNoclip() end
            StartBtn.BackgroundColor3 = Color3.fromRGB(40,140,40); StatusLabel.Text = "Stopped"; PhaseLabel.Text = "--"
            return
        end
        while running do
            if trialInProgress or trialCollecting then PhaseLabel.Text = "Paused (trial)..."; task.wait(1); continue end
            refreshChar()
            if not hasSelectedRarities(farmingTab) then StatusLabel.Text = "No rarity!"; task.wait(1); continue end
            local targets = getTargets(farmingTab)
            if #targets == 0 then StatusLabel.Text = "No targets..."; task.wait(1); continue end
            for _, target in ipairs(targets) do
                if not running or trialInProgress or trialCollecting then break end
                if not target.Part or not target.Part.Parent or not target.Object or not target.Object.Parent then continue end
                refreshChar(); local tp = target.Part.CFrame.Position
                PhaseLabel.Text = "Travel -> "..target.Name; StatusLabel.Text = "["..target.Rarity.."] "..target.Name
                if not smoothTween(CFrame.new(tp.X, tp.Y+TRAVEL_DEPTH, tp.Z), TWEEN_SPEED) or not running then continue end; task.wait(0.05)
                if waveCheckEnabled and target.Part and target.Part.Parent then
                    local fp = target.Part.CFrame.Position
                    if isWaveApproaching(fp, WAVE_SAFE_DISTANCE) then
                        waitForWavesToClear(fp, function(m) PhaseLabel.Text = m end)
                        if not running or not target.Part or not target.Part.Parent then continue end; task.wait(0.2)
                    end
                end
                if not target.Part or not target.Part.Parent then continue end
                local fp2 = target.Part.CFrame.Position
                if not smoothTween(CFrame.new(fp2.X, fp2.Y+GRAB_HEIGHT, fp2.Z), RISE_SPEED) or not running then continue end
                if waveCheckEnabled and isWaveNearby(rootPart.Position, WAVE_SAFE_DISTANCE*0.5) then
                    smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y+TRAVEL_DEPTH, rootPart.Position.Z), DIVE_SPEED*2); task.wait(0.5); continue end
                PhaseLabel.Text = "Grabbing!"
                if target.Part and target.Part.Parent then
                    if bodyVel and bodyVel.Parent then bodyVel.MaxForce = Vector3.zero end
                    rootPart.CFrame = target.Part.CFrame*CFrame.new(0,2,0); rootPart.Velocity = Vector3.zero
                    rootPart.AssemblyLinearVelocity = Vector3.zero; task.wait(0.05)
                    if bodyVel and bodyVel.Parent then bodyVel.MaxForce = Vector3.new(1e9,1e9,1e9); bodyVel.Velocity = Vector3.zero end
                end
                local pc = grabAllPrompts(target.Object) + grabNearbyPrompts(tp, 15)
                pcall(function() for _, p in pairs(target.Object:GetDescendants()) do if p:IsA("BasePart") then firetouchinterest(rootPart,p,0); task.wait(); firetouchinterest(rootPart,p,1) end end
                    if target.Part and target.Part.Parent then firetouchinterest(rootPart,target.Part,0); task.wait(); firetouchinterest(rootPart,target.Part,1) end end)
                pcall(function() for _, d in pairs(target.Object:GetDescendants()) do if d:IsA("ClickDetector") then fireclickdetector(d) end end end)
                totalGrabbed += 1; GrabLabel.Text = "Grabbed: "..totalGrabbed; LogLabel.Text = "["..target.Rarity.."] "..target.Name.." (+"..pc..")"
                task.wait(WAIT_AT_TARGET); PhaseLabel.Text = "Diving..."; refreshChar()
                smoothTween(CFrame.new(rootPart.Position.X, rootPart.Position.Y+TRAVEL_DEPTH, rootPart.Position.Z), DIVE_SPEED); task.wait(0.05)
            end
            if not AUTO_LOOP then running = false; break end; task.wait(0.3)
        end
        if autoReturnEnabled and savedCFrame then returnToSaved(true, -5); task.wait(0.2) end
        if not autoTrialRunning then unlockPhysics(); disableNoclip() end
        StartBtn.BackgroundColor3 = Color3.fromRGB(40,140,40); StatusLabel.Text = "Stopped"; PhaseLabel.Text = "--"
    end)
end
local function stopFarming()
    running = false
    tweening = false
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    -- Instantly tween back to saved position without any depth
    if rootPart and rootPart.Parent and savedCFrame then
        local safePos = savedCFrame.Position
        local safeCF = CFrame.new(safePos.X, safePos.Y, safePos.Z)
        rootPart.Velocity = Vector3.zero
        rootPart.AssemblyLinearVelocity = Vector3.zero
        rootPart.AssemblyAngularVelocity = Vector3.zero
        if bodyVel and bodyVel.Parent then
            bodyVel.Velocity = Vector3.zero
        end
        -- Immediately tween straight to saved position no depth dip
        local dist = (rootPart.Position - safeCF.Position).Magnitude
        local tweenTime = math.max(dist / TWEEN_SPEED, 0.05)
        local returnTween = TweenService:Create(rootPart, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {CFrame = safeCF})
        returnTween:Play()
        returnTween.Completed:Connect(function()
            if rootPart and rootPart.Parent then
                rootPart.Velocity = Vector3.zero
                rootPart.AssemblyLinearVelocity = Vector3.zero
            end
        end)
    elseif rootPart and rootPart.Parent then
        rootPart.Velocity = Vector3.zero
        rootPart.AssemblyLinearVelocity = Vector3.zero
        rootPart.AssemblyAngularVelocity = Vector3.zero
        if bodyVel and bodyVel.Parent then
            bodyVel.Velocity = Vector3.zero
        end
    end
end
--// ===================== BUTTON CONNECTIONS ===================== --

StartBtn.MouseButton1Click:Connect(startFarming)
StopBtn.MouseButton1Click:Connect(function() stopFarming(); stopAutoTrial() end)
RefreshBtn.MouseButton1Click:Connect(refreshActiveTab)
SelectAllBtn.MouseButton1Click:Connect(function()
    if activeTab == "Brainrot" then
        local all = true; for n in pairs(brainrotCheckboxes) do if not brainrotSelectedRarities[n] then all=false; break end end
        for n, d in pairs(brainrotCheckboxes) do if all then brainrotSelectedRarities[n]=nil; d.Check.Text=""; d.Check.BackgroundColor3=Color3.fromRGB(50,50,70)
        else brainrotSelectedRarities[n]=true; d.Check.Text="Y"; d.Check.BackgroundColor3=Color3.fromRGB(40,100,40) end end
    else
        local all = true; for n in pairs(luckyBlockCheckboxes) do if not luckyBlockSelectedRarities[n] then all=false; break end end
        for n, d in pairs(luckyBlockCheckboxes) do if all then luckyBlockSelectedRarities[n]=nil; d.Check.Text=""; d.Check.BackgroundColor3=Color3.fromRGB(50,50,70)
        else luckyBlockSelectedRarities[n]=true; d.Check.Text="Y"; d.Check.BackgroundColor3=Color3.fromRGB(100,80,0) end end
    end
end)
SavePosBtn.MouseButton1Click:Connect(function()
    if saveCurrentPosition() then updateSavedPosLabel(); LogLabel.Text = "Saved!"
        SavePosBtn.BackgroundColor3 = Color3.fromRGB(40,180,40); task.delay(0.5, function() SavePosBtn.BackgroundColor3 = Color3.fromRGB(180,120,0) end) end
end)
ReturnBtn.MouseButton1Click:Connect(function()
    if not savedCFrame then LogLabel.Text = "No saved pos!"; return end
    if running then stopFarming(); return end
    enableNoclip(); lockPhysics()
    task.spawn(function() returnToSaved(true); task.wait(0.3)
        if not autoTrialRunning then unlockPhysics(); disableNoclip() end
        StatusLabel.Text = "Returned"; PhaseLabel.Text = "--"
        ReturnBtn.BackgroundColor3 = Color3.fromRGB(40,200,40); task.delay(0.5, function() ReturnBtn.BackgroundColor3 = Color3.fromRGB(0,140,180) end) end)
end)

--// ===================== PATH LISTENERS ===================== --
BRAINROT_PATH.ChildAdded:Connect(function() task.wait(0.5); for n, d in pairs(brainrotCheckboxes) do local f = BRAINROT_PATH:FindFirstChild(n); d.CountLabel.Text = f and tostring(#f:GetChildren()) or "0" end end)
BRAINROT_PATH.ChildRemoved:Connect(function() task.wait(0.5); for n, d in pairs(brainrotCheckboxes) do local f = BRAINROT_PATH:FindFirstChild(n); d.CountLabel.Text = f and tostring(#f:GetChildren()) or "0" end end)
LUCKYBLOCK_PATH.ChildAdded:Connect(function() task.wait(0.5); for n, d in pairs(luckyBlockCheckboxes) do d.CountLabel.Text = tostring(getLuckyBlockRarityCount(n)) end end)
LUCKYBLOCK_PATH.ChildRemoved:Connect(function() task.wait(0.5); for n, d in pairs(luckyBlockCheckboxes) do d.CountLabel.Text = tostring(getLuckyBlockRarityCount(n)) end end)

--// ===================== INIT ===================== --
refreshBrainrotFolders(); refreshLuckyBlockRarities(); switchTab("Brainrot")
StatusLabel.Text = "Ready - select & START"; PhaseLabel.Text = "--"; updateSavedPosLabel()
updateTrackerLabel()
